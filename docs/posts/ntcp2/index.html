<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta name="description" content="">
<meta name="generator" content="Hugo 0.82.1" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/i2p.spec/css/style.css" type="text/css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type="text/css">
<link rel="alternate" href="/i2p.spec/index.xml" type="application/rss+xml" title="I2P Specifications">
<title>Ntcp2 - I2P Specifications</title>
</head>
<body>

<header>
  <div class="container clearfix">
    <a class="path" href="https://eyedeekay.github.io/i2p.spec/">[I2P Specifications]</a>
    <span class="caret"># _</span>
    <div class="right">
      
    </div>
  </div>
</header>

<div class="container">


<main role="main" class="article">
  
<article class="single" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2021-04-27">April 27, 2021</time></span>



  </div>
  <h1 class="headline" itemprop="headline">Ntcp2</h1>
  <section class="body" itemprop="articleBody">
    <h1 id="ntcp-2">NTCP 2</h1>
<p>Category: Transports Last updated: 2021-03 Accurate for: 0.9.50</p>
<h2 id="overview">Overview</h2>
<p>NTCP2 is an authenticated key agreement protocol that improves the
resistance of [NTCP] to various forms of automated identification and
attacks.</p>
<p>NTCP2 is designed for flexibility and coexistence with NTCP. It may be
supported on the same port as NTCP, or a different port, or without
simultaneous NTCP support at all. See the Published Router Info section
below for details.</p>
<p>As with other I2P transports, NTCP2 is defined solely for point-to-point
(router-to-router) transport of I2NP messages. It is not a
general-purpose data pipe.</p>
<p>NTCP2 is supported as of version 0.9.36. See [Prop111] for the
original proposal, including background discussion and additional
information.</p>
<h2 id="noise-protocol-framework">Noise Protocol Framework</h2>
<p>NTCP2 uses the Noise Protocol Framework [NOISE] (Revision 33,
2017-10-04). Noise has similar properties to the Station-To-Station
protocol [STS], which is the basis for the [SSU] protocol. In Noise
parlance, Alice is the initiator, and Bob is the responder.</p>
<p>NTCP2 is based on the Noise protocol
Noise_XK_25519_ChaChaPoly_SHA256. (The actual identifier for the
initial key derivation function is
&quot;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256&quot; to indicate I2P
extensions - see KDF 1 section below) This Noise protocol uses the
following primitives:</p>
<ul>
<li>Handshake Pattern: XK Alice transmits her key to Bob (X) Alice knows
Bob's static key already (K)</li>
<li>DH Function: X25519 X25519 DH with a key length of 32 bytes as
specified in [RFC-7748].</li>
<li>Cipher Function: ChaChaPoly AEAD_CHACHA20_POLY1305 as specified in
[RFC-7539] section 2.8. 12 byte nonce, with the first 4 bytes set
to zero.</li>
<li>Hash Function: SHA256 Standard 32-byte hash, already used
extensively in I2P.</li>
</ul>
<h2 id="additions-to-the-framework">Additions to the Framework</h2>
<p>NTCP2 defines the following enhancements to
Noise_XK_25519_ChaChaPoly_SHA256. These generally follow the
guidelines in [NOISE] section 13.</p>
<ol>
<li>Cleartext ephemeral keys are obfuscated with AES encryption using a
known key and IV.</li>
<li>Random cleartext padding is added to messages 1 and 2. The cleartext
padding is included in the handshake hash (MixHash) calculation. See
the KDF sections below for message 2 and message 3 part 1. Random
AEAD padding is added to message 3 and data phase messages.</li>
<li>A two-byte frame length field is added, as is required for Noise
over TCP, and as in obfs4. This is used in the data phase messages
only. Message 1 and 2 AEAD frames are fixed length. Message 3 part 1
AEAD frame is fixed length. Message 3 part 2 AEAD frame length is
specified in message 1.</li>
<li>The two-byte frame length field is obfuscated with SipHash-2-4, as
in obfs4.</li>
<li>The payload format is defined for messages 1,2,3, and the data
phase. Of course, these are not defined in the framework.</li>
</ol>
<h2 id="messages">Messages</h2>
<p>All NTCP2 messages are less than or equal to 65537 bytes in length. The
message format is based on Noise messages, with modifications for
framing and indistinguishability. Implementations using standard Noise
libraries may need to pre-process received messages to/from the Noise
message format. All encrypted fields are AEAD ciphertexts.</p>
<p>The establishment sequence is as follows:</p>
<blockquote>
<p>Alice Bob</p>
<p>SessionRequest -------------------&gt;
&lt;------------------- SessionCreated
SessionConfirmed -----------------&gt;</p>
</blockquote>
<p>Using Noise terminology, the establishment and data sequence is as
follows: (Payload Security Properties)</p>
<blockquote>
<dl>
<dt>XK(s, rs): Authentication Confidentiality</dt>
<dd>&lt;- s ... -&gt; e, es 0 2 &lt;- e, ee 2 1 -&gt; s, se 2 5 &lt;- 2 5</dd>
</dl>
</blockquote>
<p>Once a session has been established, Alice and Bob can exchange Data
messages.</p>
<p>All message types (SessionRequest, SessionCreated, SessionConfirmed,
Data and TimeSync) are specified in this section.</p>
<p>Some notations:</p>
<pre><code>- RH_A = Router Hash for Alice (32 bytes)
- RH_B = Router Hash for Bob (32 bytes)
</code></pre>
<h3 id="authenticated-encryption">Authenticated Encryption</h3>
<p>There are three separate authenticated encryption instances
(CipherStates). One during the handshake phase, and two (transmit and
receive) for the data phase. Each has its own key from a KDF.</p>
<p>Encrypted/authenticated data will be represented as</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
| + + | Encrypted and authenticated data | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</p>
</blockquote>
<h4 id="chacha20poly1305">ChaCha20/Poly1305</h4>
<p>Encrypted and authenticated data format.</p>
<p>Inputs to the encryption/decryption functions:</p>
<blockquote>
<p>k :: 32 byte cipher key, as generated from KDF</p>
<dl>
<dt>nonce :: Counter-based nonce, 12 bytes.</dt>
<dd>Starts at 0 and incremented for each message. First four bytes are
always zero. Last eight bytes are the counter, little-endian
encoded. Maximum value is 2*<em>64 - 2. Connection must be dropped
and restarted after it reaches that value. The value 2</em>*64 - 1
must never be sent.</dd>
<dt>ad :: In handshake phase:</dt>
<dd>Associated data, 32 bytes. The SHA256 hash of all preceding data.
In data phase: Zero bytes</dd>
</dl>
<p>data :: Plaintext data, 0 or more bytes</p>
</blockquote>
<p>Output of the encryption function, input to the decryption function:</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
+----+----+ + | ChaCha20 encrypted data | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+ |
Poly1305 Message Authentication Code | + (MAC) + | 16 bytes |
+----+----+----+----+----+----+----+----+</p>
<dl>
<dt>Obfs Len :: Length of (encrypted data + MAC) to follow, 16 - 65535</dt>
<dd>Obfuscation using SipHash (see below) Not used in message 1 or 2,
or message 3 part 1, where the length is fixed Not used in message
3 part 1, as the length is specified in message 1</dd>
</dl>
<p>encrypted data :: Same size as plaintext data, 0 - 65519 bytes</p>
<p>MAC :: Poly1305 message authentication code, 16 bytes</p>
</blockquote>
<p>For ChaCha20, what is described here corresponds to [RFC-7539], which
is also used similarly in TLS [RFC-7905].</p>
<h4 id="notes">Notes</h4>
<ul>
<li>Since ChaCha20 is a stream cipher, plaintexts need not be padded.
Additional keystream bytes are discarded.</li>
<li>The key for the cipher (256 bits) is agreed upon by means of the
SHA256 KDF. The details of the KDF for each message are in separate
sections below.</li>
<li>ChaChaPoly frames for messages 1, 2, and the first part of message
3, are of known size. Starting with the second part of message 3,
frames are of variable size. The message 3 part 1 size is specified
in message 1. Starting with the data phase, frames are prepended
with a two-byte length obfuscated with SipHash as in obfs4.</li>
<li>Padding is outside the authenticated data frame for messages 1 and
2. The padding is used in the KDF for the next message so tampering
will be detected. Starting in message 3, padding is inside the
authenticated data frame.</li>
</ul>
<h4 id="aead-error-handling">AEAD Error Handling</h4>
<ul>
<li>In messages 1, 2, and message 3 parts 1 and 2, the AEAD message size
is known in advance. On an AEAD authentication failure, recipient
must halt further message processing and close the connection
without responding. This should be an abnormal close (TCP RST).</li>
<li>For probing resistance, in message 1, after an AEAD failure, Bob
should set a random timeout (range TBD) and then read a random
number of bytes (range TBD) before closing the socket. Bob should
maintain a blacklist of IPs with repeated failures.</li>
<li>In the data phase, the AEAD message size is &quot;encrypted&quot;
(obfuscated) with SipHash. Care must be taken to avoid creating a
decryption oracle. On a data phase AEAD authentication failure, the
recipient should set a random timeout (range TBD) and then read a
random number of bytes (range TBD). After the read, or on read
timeout, the recipient should send a payload with a termination
block containing an &quot;AEAD failure&quot; reason code, and close the
connection.</li>
<li>Take the same error action for an invalid length field value in the
data phase.</li>
</ul>
<h3 id="key-derivation-function-kdf-for-handshake-message-1">Key Derivation Function (KDF) (for handshake message 1)</h3>
<p>The KDF generates a handshake phase cipher key k from the DH result,
using HMAC-SHA256(key, data) as defined in [RFC-2104]. These are the
InitializeSymmetric(), MixHash(), and MixKey() functions, exactly as
defined in the Noise spec.</p>
<blockquote>
<p>This is the &quot;e&quot; message pattern:</p>
<p>// Define protocol_name. Set protocol_name =
&quot;Noise_XKaesobfse+hs2+hs3_25519_ChaChaPoly_SHA256&quot; (48 bytes,
US-ASCII encoded, no NULL termination).</p>
<p>// Define Hash h = 32 bytes h = SHA256(protocol_name);</p>
<p>Define ck = 32 byte chaining key. Copy the h data to ck. Set ck = h</p>
<p>Define rs = Bob's 32-byte static key as published in the RouterInfo</p>
<p>// MixHash(null prologue) h = SHA256(h);</p>
<p>// up until here, can all be precalculated by Alice for all outgoing
connections</p>
<p>// Alice must validate that Bob's static key is a valid point on the
curve here.</p>
<p>// Bob static key // MixHash(rs) // || below means append h =
SHA256(h || rs);</p>
<p>// up until here, can all be precalculated by Bob for all incoming
connections</p>
<p>This is the &quot;e&quot; message pattern:</p>
<p>Alice generates her ephemeral DH key pair e.</p>
<p>// Alice ephemeral key X // MixHash(e.pubkey) // || below means
append h = SHA256(h || e.pubkey);</p>
<p>// h is used as the associated data for the AEAD in message 1 //
Retain the Hash h for the message 2 KDF</p>
<p>End of &quot;e&quot; message pattern.</p>
<p>This is the &quot;es&quot; message pattern:</p>
<p>// DH(e, rs) == DH(s, re) Define input_key_material = 32 byte DH
result of Alice's ephemeral key and Bob's static key Set
input_key_material = X25519 DH result</p>
<p>// MixKey(DH())</p>
<p>Define temp_key = 32 bytes Define HMAC-SHA256(key, data) as in
[RFC-2104] // Generate a temp key from the chaining key and DH
result // ck is the chaining key, defined above temp_key =
HMAC-SHA256(ck, input_key_material) // overwrite the DH result in
memory, no longer needed input_key_material = (all zeros)</p>
<p>// Output 1 // Set a new chaining key from the temp key // byte()
below means a single byte ck = HMAC-SHA256(temp_key, byte(0x01)).</p>
<p>// Output 2 // Generate the cipher key k Define k = 32 bytes // ||
below means append // byte() below means a single byte k =
HMAC-SHA256(temp_key, ck || byte(0x02)). // overwrite the temp_key
in memory, no longer needed temp_key = (all zeros)</p>
<p>// retain the chaining key ck for message 2 KDF</p>
<p>End of &quot;es&quot; message pattern.</p>
</blockquote>
<h3 id="1-sessionrequest">1) SessionRequest</h3>
<p>Alice sends to Bob.</p>
<p>Noise content: Alice's ephemeral key X Noise payload: 16 byte option
block Non-noise payload: Random padding</p>
<p>(Payload Security Properties)</p>
<blockquote>
<dl>
<dt>XK(s, rs): Authentication Confidentiality</dt>
<dd>-&gt; e, es 0 2
<p>Authentication: None (0). This payload may have been sent by any
party, including an active attacker.</p>
<p>Confidentiality: 2. Encryption to a known recipient, forward
secrecy for sender compromise only, vulnerable to replay. This
payload is encrypted based only on DHs involving the recipient's
static key pair. If the recipient's static private key is
compromised, even at a later date, this payload can be decrypted.
This message can also be replayed, since there's no ephemeral
contribution from the recipient.</p>
<dl>
<dt>&quot;e&quot;: Alice generates a new ephemeral key pair and stores it in the e</dt>
<dd>
<p>variable, writes the ephemeral public key as cleartext into
the message buffer, and hashes the public key along with the
old h to derive a new h.</p>
</dd>
<dt>&quot;es&quot;: A DH is performed between the Alice's ephemeral key pair and the</dt>
<dd>
<p>Bob's static key pair. The result is hashed along with the
old ck to derive a new ck and k, and n is set to zero.</p>
</dd>
</dl>
</dd>
</dl>
</blockquote>
<p>The X value is encrypted to ensure payload indistinguishably and
uniqueness, which are necessary DPI countermeasures. We use AES
encryption to achieve this, rather than more complex and slower
alternatives such as elligator2. Asymmetric encryption to Bob's router
public key would be far too slow. AES encryption uses Bob's router hash
as the key and Bob's IV as published in the network database.</p>
<p>AES encryption is for DPI resistance only. Any party knowing Bob's
router hash, and IV, which are published in the network database, may
decrypt the X value in this message.</p>
<p>The padding is not encrypted by Alice. It may be necessary for Bob to
decrypt the padding, to inhibit timing attacks.</p>
<p>Raw contents:</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
| + obfuscated with RH_B + | AES-CBC-256 encrypted X | + (32
bytes) + | | + + | |
+----+----+----+----+----+----+----+----+ |
| + + | ChaChaPoly frame | + (32 bytes) + | k defined in KDF for
message 1 | + n = 0 + | see KDF for associated data |
+----+----+----+----+----+----+----+----+ |
unencrypted authenticated | ~ padding (optional) ~ | length
defined in options block |
+----+----+----+----+----+----+----+----+</p>
<dl>
<dt>X :: 32 bytes, AES-256-CBC encrypted X25519 ephemeral key, little endian</dt>
<dd>key: RH_B iv: As published in Bobs network database entry</dd>
<dt>padding :: Random data, 0 or more bytes.</dt>
<dd>Total message length must be 65535 bytes or less. Total message
length must be 287 bytes or less if Bob is publishing his address
as NTCP (see Version Detection section below). Alice and Bob will
use the padding data in the KDF for message 2. It is authenticated
so that any tampering will cause the next message to fail.</dd>
</dl>
</blockquote>
<p>Unencrypted data (Poly1305 authentication tag not shown):</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
| + + | X | + (32 bytes) + | | + + | |
+----+----+----+----+----+----+----+----+ |
options | + (16 bytes) + | |
+----+----+----+----+----+----+----+----+ |
unencrypted authenticated | + padding (optional) + | length defined
in options block | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</p>
<p>X :: 32 bytes, X25519 ephemeral key, little endian</p>
<p>options :: options block, 16 bytes, see below</p>
<dl>
<dt>padding :: Random data, 0 or more bytes.</dt>
<dd>Total message length must be 65535 bytes or less. Total message
length must be 287 bytes or less if Bob is publishing his address
as &quot;NTCP&quot; (see Version Detection section below) Alice and Bob
will use the padding data in the KDF for message 2. It is
authenticated so that any tampering will cause the next message to
fail.</dd>
</dl>
</blockquote>
<p>Options block: Note: All fields are big-endian.</p>
<blockquote>
<p>+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+
| id | v  | &gt;  | L  | m3 | l  | Rs | \  |
|    | er |  p | en | p2 | en | vd | (0 |
|    |    | ad |    |    |    |    | ) |
+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+
|    | &gt;  | A  |    | &gt;  | s  | d  |    |
|    | ts |    |    | Re | er | (  |    |
|    |    |    |    |    | ve | 0) |    |
+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+</p>
<dl>
<dt>id :: 1 byte, the network ID (currently 2, except for test networks)</dt>
<dd>As of 0.9.42. See proposal 147.</dd>
</dl>
<p>ver :: 1 byte, protocol version (currently 2)</p>
<dl>
<dt>padLen :: 2 bytes, length of the padding, 0 or more</dt>
<dd>Min/max guidelines TBD. Random size from 0 to 31 bytes minimum?
(Distribution is implementation-dependent)</dd>
<dt>m3p2Len :: 2 bytes, length of the the second AEAD frame in SessionConfirmed</dt>
<dd>(message 3 part 2) See notes below</dd>
</dl>
<p>Rsvd :: 2 bytes, set to 0 for compatibility with future options</p>
<dl>
<dt>tsA :: 4 bytes, Unix timestamp, unsigned seconds.</dt>
<dd>Wraps around in 2106</dd>
</dl>
<p>Reserved :: 4 bytes, set to 0 for compatibility with future options</p>
</blockquote>
<h4 id="notes-1">Notes</h4>
<ul>
<li>
<p>When the published address is &quot;NTCP&quot;, Bob supports both NTCP and
NTCP2 on the same port. For compatibility, when initiating a
connection to an address published as &quot;NTCP&quot;, Alice must limit the
maximum size of this message, including padding, to 287 bytes or
less. This facilitates automatic protocol identification by Bob.
When published as &quot;NTCP2&quot;, there is no size restriction. See the
Published Addresses and Version Detection sections below.</p>
</li>
<li>
<p>The unique X value in the initial AES block ensure that the
ciphertext is different for every session.</p>
</li>
<li>
<p>Bob must reject connections where the timestamp value is too far off
from the current time. Call the maximum delta time &quot;D&quot;. Bob must
maintain a local cache of previously-used handshake values and
reject duplicates, to prevent replay attacks. Values in the cache
must have a lifetime of at least 2*D. The cache values are
implementation-dependent, however the 32-byte X value (or its
encrypted equivalent) may be used.</p>
</li>
<li>
<p>Diffie-Hellman ephemeral keys may never be reused, to prevent
cryptographic attacks, and reuse will be rejected as a replay
attack.</p>
</li>
<li>
<p>The &quot;KE&quot; and &quot;auth&quot; options must be compatible, i.e. the shared
secret K must be of the appropriate size. If more &quot;auth&quot; options
are added, this could implicitly change the meaning of the &quot;KE&quot;
flag to use a different KDF or a different truncation size.</p>
</li>
<li>
<p>Bob must validate that Alice's ephemeral key is a valid point on
the curve here.</p>
</li>
<li>
<p>Padding should be limited to a reasonable amount. Bob may reject
connections with excessive padding. Bob will specify his padding
options in message 2. Min/max guidelines TBD. Random size from 0 to
31 bytes minimum? (Distribution is implementation-dependent)</p>
</li>
<li>
<p>On any error, including AEAD, DH, timestamp, apparent replay, or key
validation failure, Bob must halt further message processing and
close the connection without responding. This should be an abnormal
close (TCP RST). For probing resistance, after an AEAD failure, Bob
should set a random timeout (range TBD) and then read a random
number of bytes (range TBD), before closing the socket.</p>
</li>
<li>
<p>DoS Mitigation: DH is a relatively expensive operation. As with the
previous NTCP protocol, routers should take all necessary measures
to prevent CPU or connection exhaustion. Place limits on maximum
active connections and maximum connection setups in progress.
Enforce read timeouts (both per-read and total for &quot;slowloris&quot;).
Limit repeated or simultaneous connections from the same source.
Maintain blacklists for sources that repeatedly fail. Do not respond
to AEAD failure.</p>
</li>
<li>
<p>To facilitate rapid version detection and handshaking,
implementations must ensure that Alice buffers and then flushes the
entire contents of the first message at once, including the padding.
This increases the likelihood that the data will be contained in a
single TCP packet (unless segmented by the OS or middleboxes), and
received all at once by Bob. Additionally, implementations must
ensure that Bob buffers and then flushes the entire contents of the
second message at once, including the padding. and that Bob buffers
and then flushes the entire contents of the third message at once.
This is also for efficiency and to ensure the effectiveness of the
random padding.</p>
</li>
<li>
<p>&quot;ver&quot; field: The overall Noise protocol, extensions, and NTCP
protocol including payload specifications, indicating NTCP2. This
field may be used to indicate support for future changes.</p>
</li>
<li>
<p>Message 3 part 2 length: This is the size of the second AEAD frame
(including 16-byte MAC) containing Alice's Router Info and optional
padding that will be sent in the SessionConfirmed message. As
routers periodically regenerate and republish their Router Info, the
size of the current Router Info may change before message 3 is sent.
Implementations must choose one of two strategies:</p>
<p>a) save the current Router Info to be sent in message 3, so the
size is known, and optionally add room for padding;</p>
<p>b) increase the specified size enough to allow for possible
increase in the Router Info size, and always add padding when
message 3 is actually sent. In either case, the &quot;m3p2len&quot; length
included in message 1 must be exactly the size of that frame when
sent in message 3.</p>
</li>
<li>
<p>Bob must fail the connection if any incoming data remains after
validating message 1 and reading in the padding. There should be no
extra data from Alice, as Bob has not responded with message 2 yet.</p>
</li>
<li>
<p>The network ID field is used to quickly identify cross-network
connections. If this field is nonzero, and does not match Bob's
network ID, Bob should disconnect and block future connections. Any
connections from test networks should have a different ID and will
fail the test. As of 0.9.42. See proposal 147 for more information.</p>
</li>
</ul>
<h3 id="key-derivation-function-kdf-for-handshake-message-2-and-message-3-part-1">Key Derivation Function (KDF) (for handshake message 2 and message 3 part 1)</h3>
<blockquote>
<p>// take h saved from message 1 KDF // MixHash(ciphertext) h = SHA256(h
|| 32 byte encrypted payload from message 1)</p>
<p>// MixHash(padding) // Only if padding length is nonzero h = SHA256(h
|| random padding from message 1)</p>
<p>This is the &quot;e&quot; message pattern:</p>
<p>Bob generates his ephemeral DH key pair e.</p>
<p>// h is from KDF for handshake message 1 // Bob ephemeral key Y //
MixHash(e.pubkey) // || below means append h = SHA256(h ||
e.pubkey);</p>
<p>// h is used as the associated data for the AEAD in message 2 //
Retain the Hash h for the message 3 KDF</p>
<p>End of &quot;e&quot; message pattern.</p>
<p>This is the &quot;ee&quot; message pattern:</p>
<p>// DH(e, re) Define input_key_material = 32 byte DH result of
Alice's ephemeral key and Bob's ephemeral key Set
input_key_material = X25519 DH result // overwrite Alice's
ephemeral key in memory, no longer needed // Alice: e(public and
private) = (all zeros) // Bob: re = (all zeros)</p>
<p>// MixKey(DH())</p>
<p>Define temp_key = 32 bytes Define HMAC-SHA256(key, data) as in
[RFC-2104] // Generate a temp key from the chaining key and DH
result // ck is the chaining key, from the KDF for handshake message 1
temp_key = HMAC-SHA256(ck, input_key_material) // overwrite the DH
result in memory, no longer needed input_key_material = (all zeros)</p>
<p>// Output 1 // Set a new chaining key from the temp key // byte()
below means a single byte ck = HMAC-SHA256(temp_key, byte(0x01)).</p>
<p>// Output 2 // Generate the cipher key k Define k = 32 bytes // ||
below means append // byte() below means a single byte k =
HMAC-SHA256(temp_key, ck || byte(0x02)). // overwrite the temp_key
in memory, no longer needed temp_key = (all zeros)</p>
<p>// retain the chaining key ck for message 3 KDF</p>
<p>End of &quot;ee&quot; message pattern.</p>
</blockquote>
<h3 id="2-sessioncreated">2) SessionCreated</h3>
<p>Bob sends to Alice.</p>
<p>Noise content: Bob's ephemeral key Y Noise payload: 16 byte option
block Non-noise payload: Random padding</p>
<p>(Payload Security Properties)</p>
<blockquote>
<dl>
<dt>XK(s, rs): Authentication Confidentiality</dt>
<dd>&lt;- e, ee 2 1
<p>Authentication: 2. Sender authentication resistant to
key-compromise impersonation (KCI). The sender authentication is
based on an ephemeral-static DH (&quot;es&quot; or &quot;se&quot;) between the
sender's static key pair and the recipient's ephemeral key pair.
Assuming the corresponding private keys are secure, this
authentication cannot be forged.</p>
<p>Confidentiality: 1. Encryption to an ephemeral recipient. This
payload has forward secrecy, since encryption involves an
ephemeral-ephemeral DH (&quot;ee&quot;). However, the sender has not
authenticated the recipient, so this payload might be sent to any
party, including an active attacker.</p>
<p>&quot;e&quot;: Bob generates a new ephemeral key pair and stores it in the
e variable, writes the ephemeral public key as cleartext into the
message buffer, and hashes the public key along with the old h to
derive a new h.</p>
<p>&quot;ee&quot;: A DH is performed between the Bob's ephemeral key pair
and the Alice's ephemeral key pair. The result is hashed along
with the old ck to derive a new ck and k, and n is set to zero.</p>
</dd>
</dl>
</blockquote>
<p>The Y value is encrypted to ensure payload indistinguishably and
uniqueness, which are necessary DPI countermeasures. We use AES
encryption to achieve this, rather than more complex and slower
alternatives such as elligator2. Asymmetric encryption to Alice's
router public key would be far too slow. AES encryption uses Bob's
router hash as the key and the AES state from message 1 (which was
initialized with Bob's IV as published in the network database).</p>
<p>AES encryption is for DPI resistance only. Any party knowing Bob's
router hash and IV, which are published in the network database, and
captured the first 32 bytes of message 1, may decrypt the Y value in
this message.</p>
<p>Raw contents:</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
| + obfuscated with RH_B + | AES-CBC-256 encrypted Y | + (32
bytes) + | | + + | |
+----+----+----+----+----+----+----+----+ |
ChaChaPoly frame | + Encrypted and authenticated data + | 32 bytes
| + k defined in KDF for message 2 + | n = 0; see KDF for associated
data | + + | |
+----+----+----+----+----+----+----+----+ |
unencrypted authenticated | + padding (optional) + | length defined
in options block | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</p>
<dl>
<dt>Y :: 32 bytes, AES-256-CBC encrypted X25519 ephemeral key, little endian</dt>
<dd>key: RH_B iv: Using AES state from message 1</dd>
</dl>
</blockquote>
<p>Unencrypted data (Poly1305 auth tag not shown):</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
| + + | Y | + (32 bytes) + | | + + | |
+----+----+----+----+----+----+----+----+ |
options | + (16 bytes) + | |
+----+----+----+----+----+----+----+----+ |
unencrypted authenticated | + padding (optional) + | length defined
in options block | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</p>
<p>Y :: 32 bytes, X25519 ephemeral key, little endian</p>
<p>options :: options block, 16 bytes, see below</p>
<dl>
<dt>padding :: Random data, 0 or more bytes.</dt>
<dd>Total message length must be 65535 bytes or less. Alice and Bob
will use the padding data in the KDF for message 3 part 1. It is
authenticated so that any tampering will cause the next message to
fail.</dd>
</dl>
</blockquote>
<h4 id="notes-2">Notes</h4>
<ul>
<li>Alice must validate that Bob's ephemeral key is a valid point on
the curve here.</li>
<li>Padding should be limited to a reasonable amount. Alice may reject
connections with excessive padding. Alice will specify her padding
options in message 3. Min/max guidelines TBD. Random size from 0 to
31 bytes minimum? (Distribution is implementation-dependent)</li>
<li>On any error, including AEAD, DH, timestamp, apparent replay, or key
validation failure, Alice must halt further message processing and
close the connection without responding. This should be an abnormal
close (TCP RST).</li>
<li>To facilitate rapid handshaking, implementations must ensure that
Bob buffers and then flushes the entire contents of the first
message at once, including the padding. This increases the
likelihood that the data will be contained in a single TCP packet
(unless segmented by the OS or middleboxes), and received all at
once by Alice. This is also for efficiency and to ensure the
effectiveness of the random padding.</li>
<li>Alice must fail the connection if any incoming data remains after
validating message 2 and reading in the padding. There should be no
extra data from Bob, as Alice has not responded with message 3 yet.</li>
</ul>
<p>Options block: Note: All fields are big-endian.</p>
<blockquote>
<p>+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+
| Rs | \  | pa | en | &gt;  | s  | d  |    |
| vd | (0 | dL |    | Re | er | (  |    |
|    | ) |    |    |    | ve | 0) |    |
+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+
|    | &gt;  | B  |    | &gt;  | s  | d  |    |
|    | ts |    |    | Re | er | (  |    |
|    |    |    |    |    | ve | 0) |    |
+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+</p>
<p>Reserved :: 10 bytes total, set to 0 for compatibility with future
options</p>
<dl>
<dt>padLen :: 2 bytes, big endian, length of the padding, 0 or more</dt>
<dd>Min/max guidelines TBD. Random size from 0 to 31 bytes minimum?
(Distribution is implementation-dependent)</dd>
<dt>tsB :: 4 bytes, big endian, Unix timestamp, unsigned seconds.</dt>
<dd>Wraps around in 2106</dd>
</dl>
</blockquote>
<h4 id="notes-3">Notes</h4>
<ul>
<li>Alice must reject connections where the timestamp value is too far
off from the current time. Call the maximum delta time &quot;D&quot;. Alice
must maintain a local cache of previously-used handshake values and
reject duplicates, to prevent replay attacks. Values in the cache
must have a lifetime of at least 2*D. The cache values are
implementation-dependent, however the 32-byte Y value (or its
encrypted equivalent) may be used.</li>
</ul>
<h4 id="issues">Issues</h4>
<ul>
<li>Include min/max padding options here?</li>
</ul>
<h3 id="encryption-for-for-handshake-message-3-part-1-using-message-2-kdf">Encryption for for handshake message 3 part 1, using message 2 KDF)</h3>
<blockquote>
<p>// take h saved from message 2 KDF // MixHash(ciphertext) h = SHA256(h
|| 24 byte encrypted payload from message 2)</p>
<p>// MixHash(padding) // Only if padding length is nonzero h = SHA256(h
|| random padding from message 2) // h is used as the associated
data for the AEAD in message 3 part 1, below</p>
<p>This is the &quot;s&quot; message pattern:</p>
<p>Define s = Alice's static public key, 32 bytes</p>
<p>// EncryptAndHash(s.publickey) // EncryptWithAd(h, s.publickey) //
AEAD_ChaCha20_Poly1305(key, nonce, associatedData, data) // k is
from handshake message 1 // n is 1 ciphertext =
AEAD_ChaCha20_Poly1305(k, n++, h, s.publickey) //
MixHash(ciphertext) // || below means append h = SHA256(h ||
ciphertext);</p>
<p>// h is used as the associated data for the AEAD in message 3 part 2</p>
<p>End of &quot;s&quot; message pattern.</p>
</blockquote>
<h3 id="key-derivation-function-kdf-for-handshake-message-3-part-2">Key Derivation Function (KDF) (for handshake message 3 part 2)</h3>
<blockquote>
<p>This is the &quot;se&quot; message pattern:</p>
<p>// DH(s, re) == DH(e, rs) Define input_key_material = 32 byte DH
result of Alice's static key and Bob's ephemeral key Set
input_key_material = X25519 DH result // overwrite Bob's ephemeral
key in memory, no longer needed // Alice: re = (all zeros) // Bob:
e(public and private) = (all zeros)</p>
<p>// MixKey(DH())</p>
<p>Define temp_key = 32 bytes Define HMAC-SHA256(key, data) as in
[RFC-2104] // Generate a temp key from the chaining key and DH
result // ck is the chaining key, from the KDF for handshake message 1
temp_key = HMAC-SHA256(ck, input_key_material) // overwrite the DH
result in memory, no longer needed input_key_material = (all zeros)</p>
<p>// Output 1 // Set a new chaining key from the temp key // byte()
below means a single byte ck = HMAC-SHA256(temp_key, byte(0x01)).</p>
<p>// Output 2 // Generate the cipher key k Define k = 32 bytes // ||
below means append // byte() below means a single byte k =
HMAC-SHA256(temp_key, ck || byte(0x02)).</p>
<p>// h from message 3 part 1 is used as the associated data for the AEAD
in message 3 part 2</p>
<p>// EncryptAndHash(payload) // EncryptWithAd(h, payload) //
AEAD_ChaCha20_Poly1305(key, nonce, associatedData, data) // n is 0
ciphertext = AEAD_ChaCha20_Poly1305(k, n++, h, payload) //
MixHash(ciphertext) // || below means append h = SHA256(h ||
ciphertext);</p>
<p>// retain the chaining key ck for the data phase KDF // retain the
hash h for the data phase Additional Symmetric Key (SipHash) KDF</p>
<p>End of &quot;se&quot; message pattern.</p>
<p>// overwrite the temp_key in memory, no longer needed temp_key =
(all zeros)</p>
</blockquote>
<h3 id="3-sessionconfirmed">3) SessionConfirmed</h3>
<p>Alice sends to Bob.</p>
<p>Noise content: Alice's static key Noise payload: Alice's RouterInfo
and random padding Non-noise payload: none</p>
<p>(Payload Security Properties)</p>
<blockquote>
<dl>
<dt>XK(s, rs): Authentication Confidentiality</dt>
<dd>-&gt; s, se 2 5
<p>Authentication: 2. Sender authentication resistant to
key-compromise impersonation (KCI). The sender authentication is
based on an ephemeral-static DH (&quot;es&quot; or &quot;se&quot;) between the
sender's static key pair and the recipient's ephemeral key pair.
Assuming the corresponding private keys are secure, this
authentication cannot be forged.</p>
<p>Confidentiality: 5. Encryption to a known recipient, strong
forward secrecy. This payload is encrypted based on an
ephemeral-ephemeral DH as well as an ephemeral-static DH with the
recipient's static key pair. Assuming the ephemeral private keys
are secure, and the recipient is not being actively impersonated
by an attacker that has stolen its static private key, this
payload cannot be decrypted.</p>
<p>&quot;s&quot;: Alice writes her static public key from the s variable into
the message buffer, encrypting it, and hashes the output along
with the old h to derive a new h.</p>
<p>&quot;se&quot;: A DH is performed between the Alice's static key pair and
the Bob's ephemeral key pair. The result is hashed along with the
old ck to derive a new ck and k, and n is set to zero.</p>
</dd>
</dl>
</blockquote>
<p>This contains two ChaChaPoly frames. The first is Alice's encrypted
static public key. The second is the Noise payload: Alice's encrypted
RouterInfo, optional options, and optional padding. They use different
keys, because the MixKey() function is called in between.</p>
<p>Raw contents:</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
| + ChaChaPoly frame (48 bytes) + | Encrypted and authenticated | +
Alice static key S + | (32 bytes) | + + | k defined in KDF for
message 2 | + n = 1 + | see KDF for associated data | + + | |
+----+----+----+----+----+----+----+----+ |
| + Length specified in message 1 + | | + ChaChaPoly frame + |
Encrypted and authenticated | + + | Alice RouterInfo | + using
block format 2 + | Alice Options (optional) | + using block format 1</p>
<ul>
<li>| Arbitrary padding | + using block format 254 + | | + + | k
defined in KDF for message 3 part 2 | + n = 0 + | see KDF for
associated data | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</li>
</ul>
<dl>
<dt>S :: 32 bytes, ChaChaPoly encrypted Alice's X25519 static key, little endian</dt>
<dd>inside 48 byte ChaChaPoly frame</dd>
</dl>
</blockquote>
<p>Unencrypted data (Poly1305 auth tags not shown):</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
| + + | S | + Alice static key + | (32 bytes) | + + | | + +
+----+----+----+----+----+----+----+----+ |
| + + | | + + | Alice RouterInfo block | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+ |
| + Optional Options block + | | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+ |
| + Optional Padding block + | | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</p>
<p>S :: 32 bytes, Alice's X25519 static key, little endian</p>
</blockquote>
<h4 id="notes-4">Notes</h4>
<ul>
<li>
<p>Bob must perform the usual Router Info validation. Ensure the
signature type is supported, verify the signature, verify the
timestamp is within bounds, and any other checks necessary.</p>
</li>
<li>
<p>Bob must verify that Alice's static key received in the first frame
matches the static key in the Router Info. Bob must first search the
Router Info for a NTCP or NTCP2 Router Address with a matching
version (v) option. See Published Router Info and Unpublished Router
Info sections below.</p>
</li>
<li>
<p>If Bob has an older version of Alice's RouterInfo in his netdb,
verify that the static key in the router info is the same in both,
if present, and if the older version is less than XXX old (see key
rotate time below)</p>
</li>
<li>
<p>Bob must validate that Alice's static key is a valid point on the
curve here.</p>
</li>
<li>
<p>Options should be included, to specify padding parameters.</p>
</li>
<li>
<p>On any error, including AEAD, RI, DH, timestamp, or key validation
failure, Bob must halt further message processing and close the
connection without responding. This should be an abnormal close (TCP
RST).</p>
</li>
<li>
<p>To facilitate rapid handshaking, implementations must ensure that
Alice buffers and then flushes the entire contents of the third
message at once, including both AEAD frames. This increases the
likelihood that the data will be contained in a single TCP packet
(unless segmented by the OS or middleboxes), and received all at
once by Bob. This is also for efficiency and to ensure the
effectiveness of the random padding.</p>
</li>
<li>
<p>Message 3 part 2 frame length: The length of this frame (including
MAC) is sent by Alice in message 1. See that message for important
notes on allowing enough room for padding.</p>
</li>
<li>
<p>Message 3 part 2 frame content: This format of this frame is the
same as the format of data phase frames, except that the length of
the frame is sent by Alice in message 1. See below for the data
phase frame format. The frame must contain 1 to 3 blocks in the
following order:</p>
<ol>
<li>Alice's Router Info block (required)</li>
<li>Options block (optional)</li>
</ol>
<p>3) Padding block (optional) This frame must never contain any other
block type.</p>
</li>
<li>
<p>Message 3 part 2 padding is not required if Alice appends a data
phase frame (optionally containing padding) to the end of message 3
and sends both at once, as it will appear as one big stream of bytes
to an observer. As Alice will generally, but not always, have an
I2NP message to send to Bob (that's why she connected to him), this
is the recommended implementation, for efficiency and to ensure the
effectiveness of the random padding.</p>
</li>
<li>
<p>Total length of both Message 3 AEAD frames (parts 1 and 2) is 65535
bytes; part 1 is 48 bytes so part 2 max frame length is 65487; part
2 max plaintext length excluding MAC is 65471.</p>
</li>
</ul>
<h3 id="key-derivation-function-kdf-for-data-phase">Key Derivation Function (KDF) (for data phase)</h3>
<p>The data phase uses a zero-length associated data input.</p>
<p>The KDF generates two cipher keys k_ab and k_ba from the chaining key
ck, using HMAC-SHA256(key, data) as defined in [RFC-2104]. This is the
Split() function, exactly as defined in the Noise spec.</p>
<blockquote>
<p>ck = from handshake phase</p>
<p>// k_ab, k_ba = HKDF(ck, zerolen) // ask_master = HKDF(ck, zerolen,
info=&quot;ask&quot;)</p>
<p>// zerolen is a zero-length byte array temp_key = HMAC-SHA256(ck,
zerolen) // overwrite the chaining key in memory, no longer needed ck
= (all zeros)</p>
<p>// Output 1 // cipher key, for Alice transmits to Bob (Noise doesn't
make clear which is which, but Java code does) k_ab =
HMAC-SHA256(temp_key, byte(0x01)).</p>
<p>// Output 2 // cipher key, for Bob transmits to Alice (Noise doesn't
make clear which is which, but Java code does) k_ba =
HMAC-SHA256(temp_key, k_ab || byte(0x02)).</p>
<p>KDF for SipHash for length field: Generate an Additional Symmetric Key
(ask) for SipHash SipHash uses two 8-byte keys (big endian) and 8 byte
IV for first data.</p>
<p>// &quot;ask&quot; is 3 bytes, US-ASCII, no null termination ask_master =
HMAC-SHA256(temp_key, &quot;ask&quot; || byte(0x01)) // sip_master =
HKDF(ask_master, h || &quot;siphash&quot;) // &quot;siphash&quot; is 7 bytes,
US-ASCII, no null termination // overwrite previous temp_key in
memory // h is from KDF for message 3 part 2 temp_key =
HMAC-SHA256(ask_master, h || &quot;siphash&quot;) // overwrite ask_master
in memory, no longer needed ask_master = (all zeros) sip_master =
HMAC-SHA256(temp_key, byte(0x01))</p>
<p>Alice to Bob SipHash k1, k2, IV: // sipkeys_ab, sipkeys_ba =
HKDF(sip_master, zerolen) // overwrite previous temp_key in memory
temp_key = HMAC-SHA256(sip_master, zerolen) // overwrite sip_master
in memory, no longer needed sip_master = (all zeros)</p>
<p>sipkeys_ab = HMAC-SHA256(temp_key, byte(0x01)). sipk1_ab =
sipkeys_ab[0:7], little endian sipk2_ab = sipkeys_ab[8:15],
little endian sipiv_ab = sipkeys_ab[16:23]</p>
<p>Bob to Alice SipHash k1, k2, IV:</p>
<p>sipkeys_ba = HMAC-SHA256(temp_key, sipkeys_ab || byte(0x02)).
sipk1_ba = sipkeys_ba[0:7], little endian sipk2_ba =
sipkeys_ba[8:15], little endian sipiv_ba = sipkeys_ba[16:23]</p>
<p>// overwrite the temp_key in memory, no longer needed temp_key =
(all zeros)</p>
</blockquote>
<h3 id="4-data-phase">4) Data Phase</h3>
<p>Noise payload: As defined below, including random padding Non-noise
payload: none</p>
<p>Starting with the 2nd part of message 3, all messages are inside an
authenticated and encrypted ChaChaPoly &quot;frame&quot; with a prepended
two-byte obfuscated length. All padding is inside the frame. Inside the
frame is a standard format with zero or more &quot;blocks&quot;. Each block has
a one-byte type and a two-byte length. Types include date/time, I2NP
message, options, termination, and padding.</p>
<p>Note: Bob may, but is not required, to send his RouterInfo to Alice as
his first message to Alice in the data phase.</p>
<p>(Payload Security Properties)</p>
<blockquote>
<dl>
<dt>XK(s, rs): Authentication Confidentiality</dt>
<dd>&lt;- 2 5 -&gt; 2 5
<p>Authentication: 2. Sender authentication resistant to
key-compromise impersonation (KCI). The sender authentication is
based on an ephemeral-static DH (&quot;es&quot; or &quot;se&quot;) between the
sender's static key pair and the recipient's ephemeral key pair.
Assuming the corresponding private keys are secure, this
authentication cannot be forged.</p>
<p>Confidentiality: 5. Encryption to a known recipient, strong
forward secrecy. This payload is encrypted based on an
ephemeral-ephemeral DH as well as an ephemeral-static DH with the
recipient's static key pair. Assuming the ephemeral private keys
are secure, and the recipient is not being actively impersonated
by an attacker that has stolen its static private key, this
payload cannot be decrypted.</p>
</dd>
</dl>
</blockquote>
<h4 id="notes-5">Notes</h4>
<ul>
<li>For efficiency and to minimize identification of the length field,
implementations must ensure that the sender buffers and then flushes
the entire contents of data messages at once, including the length
field and the AEAD frame. This increases the likelihood that the
data will be contained in a single TCP packet (unless segmented by
the OS or middleboxes), and received all at once the other party.
This is also for efficiency and to ensure the effectiveness of the
random padding.</li>
<li>The router may choose to terminate the session on AEAD error, or may
continue to attempt communications. If continuing, the router should
terminate after repeated errors.</li>
</ul>
<h4 id="siphash-obfuscated-length">SipHash obfuscated length</h4>
<p>Reference: [SipHash]</p>
<p>Once both sides have completed the handshake, they transfer payloads
that are then encrypted and authenticated in ChaChaPoly &quot;frames&quot;.</p>
<p>Each frame is preceded by a two-byte length, big endian. This length
specifies the number of encrypted frame bytes to follow, including the
MAC. To avoid transmitting identifiable length fields in stream, the
frame length is obfuscated by XORing a mask derived from SipHash, as
initialized from the data phase KDF. Note that the two directions have
unique SipHash keys and IVs from the KDF.</p>
<blockquote>
<p>sipk1, sipk2 = The SipHash keys from the KDF. (two 8-byte long
integers) IV[0] = sipiv = The SipHash IV from the KDF. (8 bytes)
length is big endian. For each frame: IV[n] = SipHash-2-4(sipk1,
sipk2, IV[n-1]) Mask[n] = First 2 bytes of IV[n]
obfuscatedLength = length ^ Mask[n]</p>
<p>The first length output will be XORed with with IV[1].</p>
</blockquote>
<p>The receiver has the identical SipHash keys and IV. Decoding the length
is done by deriving the mask used to obfsucate the length and XORing the
truncated digest to obtain the length of the frame. The frame length is
the total length of the encrypted frame including the MAC.</p>
<h4 id="notes-6">Notes</h4>
<ul>
<li>If you use a SipHash library function that returns an unsigned long
integer, use the least significant two bytes as the Mask. Convert
the long integer to the next IV as little endian.</li>
</ul>
<h4 id="raw-contents">Raw contents</h4>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
+----+----+ + | | + ChaChaPoly frame + | Encrypted and
authenticated | + key is k_ab for Alice to Bob + | key is k_ba for
Bob to Alice | + as defined in KDF for data phase + | n starts at 0
and increments | + for each frame in that direction + | no
associated data | + 16 bytes minimum + | | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</p>
<dl>
<dt>obf size :: 2 bytes length obfuscated with SipHash</dt>
<dd>when de-obfuscated: 16 - 65535</dd>
</dl>
<p>Minimum size including length field is 18 bytes. Maximum size
including length field is 65537 bytes. Obfuscated length is 2 bytes.
Maximum ChaChaPoly frame is 65535 bytes.</p>
</blockquote>
<h4 id="unencrypted-data">Unencrypted data</h4>
<p>There are zero or more blocks in the encrypted frame. Each block
contains a one-byte identifier, a two-byte length, and zero or more
bytes of data.</p>
<p>For extensibility, receivers must ignore blocks with unknown
identifiers, and treat them as padding.</p>
<p>Encrypted data is 65535 bytes max, including a 16-byte authentication
header, so the max unencrypted data is 65519 bytes.</p>
<p>(Poly1305 auth tag not shown):</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ size
| data | +----+----+----+ + | | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+ size
| data | +----+----+----+ + | | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+ ~ .
. . ~</p>
<dl>
<dt>blk :: 1 byte</dt>
<dd>0 for datetime 1 for options 2 for RouterInfo 3 for I2NP message 4
for termination 224-253 reserved for experimental features 254 for
padding 255 reserved for future extension</dd>
</dl>
<p>size :: 2 bytes, big endian, size of data to follow, 0 - 65516 data ::
the data</p>
<p>Maximum ChaChaPoly frame is 65535 bytes. Poly1305 tag is 16 bytes
Maximum total block size is 65519 bytes Maximum single block size is
65519 bytes Block type is 1 byte Block length is 2 bytes Maximum
single block data size is 65516 bytes.</p>
</blockquote>
<h4 id="block-ordering-rules">Block Ordering Rules</h4>
<p>In the handshake message 3 part 2, order must be: RouterInfo, followed
by Options if present, followed by Padding if present. No other blocks
are allowed.</p>
<p>In the data phase, order is unspecified, except for the following
requirements: Padding, if present, must be the last block. Termination,
if present, must be the last block except for Padding.</p>
<p>There may be multiple I2NP blocks in a single frame. Multiple Padding
blocks are not allowed in a single frame. Other block types probably
won't have multiple blocks in a single frame, but it is not prohibited.</p>
<h4 id="datetime">DateTime</h4>
<p>Special case for time synchronization:</p>
<blockquote>
<p>+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+
| 0  | &gt;  |    |    | t  | ta |    |
|    |  4 |    |    | im | mp |    |
|    |    |    |    | es |    |    |
+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+</p>
<p>blk :: 0 size :: 2 bytes, big endian, value = 4 timestamp :: Unix
timestamp, unsigned seconds. Wraps around in 2106</p>
</blockquote>
<h4 id="options">Options</h4>
<p>Pass updated options. Options include: Min and max padding.</p>
<p>Options block will be variable length.</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ | 1
| size tmaxrmax
+----+----+----+----+----+----+----+----+ rdmy
| tdelay | rdelay | |
~----+----+----+----+----+----+----+ ~ |
more_options | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</p>
<p>blk :: 1 size :: 2 bytes, big endian, size of options to follow, 12
bytes minimum</p>
<dl>
<dt>tmin, tmax, rmin, rmax :: requested padding limits</dt>
<dd>tmin and rmin are for desired resistance to traffic analysis. tmax
and rmax are for bandwidth limits. tmin and tmax are the transmit
limits for the router sending this options block. rmin and rmax
are the receive limits for the router sending this options block.
Each is a 4.4 fixed-point float representing 0 to 15.9375 (or
think of it as an unsigned 8-bit integer divided by 16.0). This is
the ratio of padding to data. Examples: Value of 0x00 means no
padding Value of 0x01 means add 6 percent padding Value of 0x10
means add 100 percent padding Value of 0x80 means add 800 percent
(8x) padding Alice and Bob will negotiate the minimum and maximum
in each direction. These are guidelines, there is no enforcement.
Sender should honor receiver's maximum. Sender may or may not
honor receiver's minimum, within bandwidth constraints.</dd>
</dl>
<p>tdmy: Max dummy traffic willing to send, 2 bytes big endian, bytes/sec
average rdmy: Requested dummy traffic, 2 bytes big endian, bytes/sec
average tdelay: Max intra-message delay willing to insert, 2 bytes big
endian, msec average rdelay: Requested intra-message delay, 2 bytes
big endian, msec average</p>
<p>Padding distribution specified as additional parameters? Random delay
specified as additional parameters?</p>
<p>more_options :: Format TBD</p>
</blockquote>
<h4 id="options-issues">Options Issues</h4>
<ul>
<li>Options format is TBD.</li>
<li>Options negotiation is TBD.</li>
</ul>
<h4 id="routerinfo">RouterInfo</h4>
<p>Pass Alice's RouterInfo to Bob. Used in handshake message 3 part 2.
Pass Alice's RouterInfo to Bob, or Bob's to Alice. Used optionally in
the data phase.</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ | 2
| size RouterInfo | +----+----+----+----+ + | (Alice RI
in handshake msg 3 part 2) | ~ (Alice, Bob, or third-party ~ | RI
in data phase) | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</p>
<p>blk :: 2 size :: 2 bytes, big endian, size of flag + router info to
follow flg :: 1 byte flags bit order: 76543210 bit 0: 0 for local
store, 1 for flood request bits 7-1: Unused, set to 0 for future
compatibility routerinfo :: Alice's or Bob's RouterInfo</p>
</blockquote>
<h4 id="notes-7">Notes</h4>
<ul>
<li>When used in the data phase, receiver (Alice or Bob) shall validate
that it's the same Router Hash as originally sent (for Alice) or
sent to (for Bob). Then, treat it as a local I2NP DatabaseStore
Message. Validate signature, validate more recent timestamp, and
store in the local netdb. If the flag bit 0 is 1, and the receiving
party is floodfill, treat it as a DatabaseStore Message with a
nonzero reply token, and flood it to the nearest floodfills.</li>
<li>The Router Info is NOT compressed with gzip (unlike in a
DatabaseStore Message, where it is)</li>
<li>Flooding must not be requested unless there are published
RouterAddresses in the RouterInfo. The receiving router must not
flood the RouterInfo unless there are published RouterAddresses in
it.</li>
<li>Implementers must ensure that when reading a block, malformed or
malicious data will not cause reads to overrun into the next block.</li>
<li>This protocol does not provide an acknowledgement that the
RouterInfo was received, stored, or flooded (either in the handshake
or data phase). If acknowledgement is desired, and the receiver is
floodfill, the sender should instead send a standard I2NP
DatabaseStoreMessage with a reply token.</li>
</ul>
<h4 id="issues-1">Issues</h4>
<ul>
<li>Could also be used in data phase, instead of a I2NP
DatabaseStoreMessage. For example, Bob could use it to start off the
data phase.</li>
<li>Is it allowed for this to contain the RI for routers other than the
originator, as a general replacement for DatabaseStoreMessages, e.g.
for flooding by floodfills?</li>
</ul>
<h4 id="i2np-message">I2NP Message</h4>
<p>An single I2NP message with a modified header. I2NP messages may not be
fragmented across blocks or across ChaChaPoly frames.</p>
<p>This uses the first 9 bytes from the standard NTCP I2NP header, and
removes the last 7 bytes of the header, as follows: shorten the
expiration from 8 to 4 bytes (seconds instead of milliseconds, same as
for SSU), remove the 2 byte length (use the block size - 9), and remove
the one-byte SHA256 checksum.</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ | 3
| size msg id |
+----+----+----+----+----+----+----+----+ |
short exp | message | +----+----+----+----+ + | | ~ .
. . ~ | |
+----+----+----+----+----+----+----+----+</p>
<p>blk :: 3 size :: 2 bytes, big endian, size of type + msg id + exp +
message to follow I2NP message body size is (size - 9). type :: 1
byte, I2NP msg type, see I2NP spec msg id :: 4 bytes, big endian, I2NP
message ID short exp :: 4 bytes, big endian, I2NP message expiration,
Unix timestamp, unsigned seconds. Wraps around in 2106 message :: I2NP
message body</p>
</blockquote>
<h4 id="notes-8">Notes</h4>
<ul>
<li>Implementers must ensure that when reading a block, malformed or
malicious data will not cause reads to overrun into the next block.</li>
</ul>
<h4 id="termination">Termination</h4>
<p>Noise recommends an explicit termination message. Original NTCP doesn't
have one. Drop the connection. This must be the last non-padding block
in the frame.</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ | 4
| size | valid data frames |
+----+----+----+----+----+----+----+----+
received | rsn| addl data | +----+----+----+----+ + ~
. . . ~
+----+----+----+----+----+----+----+----+</p>
<p>blk :: 4 size :: 2 bytes, big endian, value = 9 or more valid received
:: The number of valid AEAD data phase frames received (current
receive nonce value) 0 if error occurs in handshake phase 8 bytes, big
endian rsn :: reason, 1 byte: 0: normal close or unspecified 1:
termination received 2: idle timeout 3: router shutdown 4: data phase
AEAD failure 5: incompatible options 6: incompatible signature type 7:
clock skew 8: padding violation 9: AEAD framing error 10: payload
format error 11: message 1 error 12: message 2 error 13: message 3
error 14: intra-frame read timeout 15: RI signature verification fail
16: s parameter missing, invalid, or mismatched in RouterInfo 17:
banned addl data :: optional, 0 or more bytes, for future expansion,
debugging, or reason text. Format unspecified and may vary based on
reason code.</p>
</blockquote>
<h4 id="notes-9">Notes</h4>
<p>Not all reasons may actually be used, implementation dependent.
Handshake failures will generally result in a close with TCP RST
instead. See notes in handshake message sections above. Additional
reasons listed are for consistency, logging, debugging, or if policy
changes.</p>
<h4 id="padding">Padding</h4>
<p>This is for padding inside AEAD frames. Padding for messages 1 and 2 are
outside AEAD frames. All padding for message 3 and the data phase are
inside AEAD frames.</p>
<p>Padding inside AEAD should roughly adhere to the negotiated parameters.
Bob sent his requested tx/rx min/max parameters in message 2. Alice sent
her requested tx/rx min/max parameters in message 3. Updated options may
be sent during the data phase. See options block information above.</p>
<p>If present, this must be the last block in the frame.</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ size
| padding | +----+----+----+ + | | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</p>
<p>blk :: 254 size :: 2 bytes, big endian, size of padding to follow
padding :: random data</p>
</blockquote>
<h4 id="notes-10">Notes</h4>
<ul>
<li>Padding strategies TBD.</li>
<li>Minimum padding TBD.</li>
<li>Padding-only frames are allowed.</li>
<li>Padding defaults TBD.</li>
<li>See options block for padding parameter negotiation</li>
<li>See options block for min/max padding parameters</li>
<li>Noise limits messages to 64KB. If more padding is necessary, send
multiple frames.</li>
<li>Router response on violation of negotiated padding is
implementation-dependent.</li>
</ul>
<h4 id="other-block-types">Other block types</h4>
<p>Implementations should ignore unknown block types for forward
compatibility, except in message 3 part 2, where unknown blocks are not
allowed.</p>
<h4 id="future-work">Future work</h4>
<ul>
<li>The padding length is either to be decided on a per-message basis
and estimates of the length distribution, or random delays should be
added. These countermeasures are to be included to resist DPI, as
message sizes would otherwise reveal that I2P traffic is being
carried by the transport protocol. The exact padding scheme is an
area of future work.</li>
</ul>
<h3 id="5-termination">5) Termination</h3>
<p>Connections may be terminated via normal or abnormal TCP socket close,
or, as Noise recommends, an explicit termination message. The explicit
termination message is defined in the data phase above.</p>
<p>Upon any normal or abnormal termination, routers should zero-out any
in-memory ephemeral data, including handshake ephemeral keys, symmetric
crypto keys, and related information.</p>
<h2 id="published-router-info">Published Router Info</h2>
<h3 id="capabilities">Capabilities</h3>
<p>As of release 0.9.50, the &quot;caps&quot; option is supported in NTCP2
addresses, similar to SSU. One or more capabilities may be published in
the &quot;caps&quot; option. Capabilities may be in any order, but &quot;46&quot; is the
recommended order, for consistency across implementations. There are two
capabilities defined:</p>
<p>4: Indicates outbound IPv4 capability. If an IP is published in the host
field, this capability is not necessary. If the router is hidden, or
NTCP2 is outbound only, '4' and '6' may be combined in a single
address.</p>
<p>6: Indicates outbound IPv6 capability. If an IP is published in the host
field, this capability is not necessary. If the router is hidden, or
NTCP2 is outbound only, '4' and '6' may be combined in a single
address.</p>
<h3 id="published-addresses">Published Addresses</h3>
<p>The published RouterAddress (part of the RouterInfo) will have a
protocol identifier of either &quot;NTCP&quot; or &quot;NTCP2&quot;.</p>
<p>The RouterAddress must contain &quot;host&quot; and &quot;port&quot; options, as in the
current NTCP protocol.</p>
<p>The RouterAddress must contain three options to indicate NTCP2 support:</p>
<ul>
<li>s=(Base64 key) The current Noise static public key (s) for this
RouterAddress. Base 64 encoded using the standard I2P Base 64
alphabet. 32 bytes in binary, 44 bytes as Base 64 encoded,
little-endian X25519 public key.</li>
<li>i=(Base64 IV) The current IV for encrypting the X value in message 1
for this RouterAddress. Base 64 encoded using the standard I2P Base
64 alphabet. 16 bytes in binary, 24 bytes as Base 64 encoded,
big-endian.</li>
<li>v=2 The current version (2). When published as &quot;NTCP&quot;, additional
support for version 1 is implied. Support for future versions will
be with comma-separated values, e.g. v=2,3 Implementation should
verify compatibility, including multiple versions if a comma is
present. Comma-separated versions must be in numerical order.</li>
</ul>
<p>Alice must verify that all three options are present and valid before
connecting using the NTCP2 protocol.</p>
<p>When published as &quot;NTCP&quot; with &quot;s&quot;, &quot;i&quot;, and &quot;v&quot; options, the
router must accept incoming connections on that host and port for both
NTCP and NTCP2 protocols, and automatically detect the protocol version.</p>
<p>When published as &quot;NTCP2&quot; with &quot;s&quot;, &quot;i&quot;, and &quot;v&quot; options, the
router accepts incoming connections on that host and port for the NTCP2
protocol only.</p>
<p>If a router supports both NTCP1 and NTCP2 connections but does not
implement automatic version detection for incoming connections, it must
advertise both &quot;NTCP&quot; and &quot;NTCP2&quot; addresses, and include the NTCP2
options in the &quot;NTCP2&quot; address only. The router should set a lower
cost value (higher priority) in the &quot;NTCP2&quot; address than the &quot;NTCP&quot;
address, so NTCP2 is preferred.</p>
<p>If multiple NTCP2 RouterAddresses (either as &quot;NTCP&quot; or &quot;NTCP2&quot;) are
published in the same RouterInfo (for additional IP addresses or ports),
all addresses specifying the same port must contain the identical NTCP2
options and values. In particular, all must contain the same static key
and iv.</p>
<h3 id="unpublished-ntcp2-address">Unpublished NTCP2 Address</h3>
<p>If Alice does not publish her NTCP2 address (as &quot;NTCP&quot; or &quot;NTCP2&quot;)
for incoming connections, she must publish a &quot;NTCP2&quot; router address
containing only her static key and NTCP2 version, so that Bob may
validate the key after receiving Alice's RouterInfo in message 3 part
2.</p>
<ul>
<li>s=(Base64 key) As defined above for published addresses.</li>
<li>v=2 As defined above for published addresses.</li>
</ul>
<p>This router address will not contain &quot;i&quot;, &quot;host&quot; or &quot;port&quot;
options, as these are not required for outbound NTCP2 connections. The
published cost for this address does not strictly matter, as it is
inbound only; however, it may be helpful to other routers if the cost is
set higher (lower priority) than other addresses. The suggested value is
14.</p>
<p>Alice may also simply add the &quot;s&quot; and &quot;v&quot; options to an existing
published &quot;NTCP&quot; address.</p>
<h3 id="public-key-and-iv-rotation">Public Key and IV Rotation</h3>
<p>Due to caching of RouterInfos, routers must not rotate the static public
key or IV while the router is up, whether in a published address or not.
Routers must persistently store this key and IV for reuse after an
immediate restart, so incoming connections will continue to work, and
restart times are not exposed. Routers must persistently store, or
otherwise determine, last-shutdown time, so that the previous downtime
may be calculated at startup.</p>
<p>Subject to concerns about exposing restart times, routers may rotate
this key or IV at startup if the router was previously down for some
time (a couple hours at least).</p>
<p>If the router has any published NTCP2 RouterAddresses (as NTCP or
NTCP2), the minimum downtime before rotation should be much longer, for
example one month, unless the local IP address has changed or the router
&quot;rekeys&quot;.</p>
<p>If the router has any published SSU RouterAddresses, but not NTCP2 (as
NTCP or NTCP2) the minimum downtime before rotation should be longer,
for example one day, unless the local IP address has changed or the
router &quot;rekeys&quot;. This applies even if the published SSU address has
introducers.</p>
<p>If the router does not have any published RouterAddresses (NTCP, NTCP2,
or SSU), the minimum downtime before rotation may be as short as two
hours, even if the IP address changes, unless the router &quot;rekeys&quot;.</p>
<p>If the router &quot;rekeys&quot; to a different Router Hash, it should generate
a new noise key and IV as well.</p>
<p>Implementations must be aware that changing the static public key or IV
will prohibit incoming NTCP2 connections from routers that have cached
an older RouterInfo. RouterInfo publishing, tunnel peer selection
(including both OBGW and IB closest hop), zero-hop tunnel selection,
transport selection, and other implementation strategies must take this
into account.</p>
<p>IV rotation is subject to identical rules as key rotation, except that
IVs are not present except in published RouterAddresses, so there is no
IV for hidden or firewalled routers. If anything changes (version, key,
options?) it is recommended that the IV change as well.</p>
<p>Note: The minimum downtime before rekeying may be modified to ensure
network health, and to prevent reseeding by a router down for a moderate
amount of time.</p>
<h2 id="version-detection">Version Detection</h2>
<p>When published as &quot;NTCP&quot;, the router must automatically detect the
protocol version for incoming connections.</p>
<p>This detection is implementation-dependent, but here is some general
guidance.</p>
<p>To detect the version of an incoming NTCP connection, Bob proceeds as
follows:</p>
<ul>
<li>
<p>Wait for at least 64 bytes (minimum NTCP2 message 1 size)</p>
</li>
<li>
<p>If the initial received data is 288 or more bytes, the incoming
connection is version 1.</p>
</li>
<li>
<p>If less than 288 bytes, either</p>
<blockquote>
<ul>
<li>
<p>Wait for a short time for more data (good strategy before
widespread NTCP2 adoption) if at least 288 total received,
it's NTCP 1.</p>
</li>
<li>
<p>Try the first stages of decoding as version 2, if it fails,
wait a short time for more data (good strategy after
widespread NTCP2 adoption)</p>
<blockquote>
<ul>
<li>Decrypt the first 32 bytes (the X key) of the
SessionRequest packet using AES-256 with key RH_B.</li>
<li>Verify a valid point on the curve. If it fails, wait a
short time for more data for NTCP 1</li>
<li>Verify the AEAD frame. If it fails, wait a short time
for more data for NTCP 1</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<p>Note that changes or additional strategies may be recommended if we
detect active TCP segmentation attacks on NTCP 1.</p>
<p>To facilitate rapid version detection and handshaking, implementations
must ensure that Alice buffers and then flushes the entire contents of
the first message at once, including the padding. This increases the
likelihood that the data will be contained in a single TCP packet
(unless segmented by the OS or middleboxes), and received all at once by
Bob. This is also for efficiency and to ensure the effectiveness of the
random padding. This applies to both NTCP and NTCP2 handshakes.</p>
<h2 id="variants-fallbacks-and-general-issues">Variants, Fallbacks, and General Issues</h2>
<ul>
<li>If Alice and Bob both support NTCP2, Alice should connect with
NTCP2.</li>
<li>If Alice fails to connect to Bob using NTCP2 for any reason, the
connection fails. Alice may not retry using NTCP 1.</li>
</ul>
<h2 id="references">References</h2>
<dl>
<dt>[IACR-1150]</dt>
<dd>
<p><a href="https://eprint.iacr.org/2015/1150">https://eprint.iacr.org/2015/1150</a></p>
</dd>
<dt>[NetDB]</dt>
<dd>
<p><a href="https://geti2p.net/en/docs/how/network-database">https://geti2p.net/en/docs/how/network-database</a></p>
</dd>
<dt>[NOISE]</dt>
<dd>
<p><a href="https://noiseprotocol.org/noise.html">https://noiseprotocol.org/noise.html</a></p>
</dd>
<dt>[NTCP]</dt>
<dd>
<p><a href="https://geti2p.net/en/docs/transport/ntcp">https://geti2p.net/en/docs/transport/ntcp</a></p>
</dd>
<dt>[Prop104]</dt>
<dd>
<p><a href="https://geti2p.net/spec/proposals/104-tls-transport">https://geti2p.net/spec/proposals/104-tls-transport</a></p>
</dd>
<dt>[Prop109]</dt>
<dd>
<p><a href="https://geti2p.net/spec/proposals/109-pt-transport">https://geti2p.net/spec/proposals/109-pt-transport</a></p>
</dd>
<dt>[Prop111]</dt>
<dd>
<p><a href="https://geti2p.net/spec/proposals/111-ntcp-2">https://geti2p.net/spec/proposals/111-ntcp-2</a></p>
</dd>
<dt>[RFC-2104]</dt>
<dd>
<p><a href="https://tools.ietf.org/html/rfc2104">https://tools.ietf.org/html/rfc2104</a></p>
</dd>
<dt>[RFC-3526]</dt>
<dd>
<p><a href="https://tools.ietf.org/html/rfc3526">https://tools.ietf.org/html/rfc3526</a></p>
</dd>
<dt>[RFC-6151]</dt>
<dd>
<p><a href="https://tools.ietf.org/html/rfc6151">https://tools.ietf.org/html/rfc6151</a></p>
</dd>
<dt>[RFC-7539]</dt>
<dd>
<p><a href="https://tools.ietf.org/html/rfc7539">https://tools.ietf.org/html/rfc7539</a></p>
</dd>
<dt>[RFC-7748]</dt>
<dd>
<p><a href="https://tools.ietf.org/html/rfc7748">https://tools.ietf.org/html/rfc7748</a></p>
</dd>
<dt>[RFC-7905]</dt>
<dd>
<p><a href="https://tools.ietf.org/html/rfc7905">https://tools.ietf.org/html/rfc7905</a></p>
</dd>
<dt>[RouterAddress]</dt>
<dd>
<p><a href="https://geti2p.net/spec/common-structures#struct-routeraddress">https://geti2p.net/spec/common-structures#struct-routeraddress</a></p>
</dd>
<dt>[RouterIdentity]</dt>
<dd>
<p><a href="https://geti2p.net/spec/common-structures#struct-routeridentity">https://geti2p.net/spec/common-structures#struct-routeridentity</a></p>
</dd>
<dt>[SIDH]</dt>
<dd>
<p>De Feo, Luca; Jao, Plut., Towards quantum-resistant cryptosystems
from supersingular elliptic curve isogenies</p>
</dd>
<dt>[SigningPublicKey]</dt>
<dd>
<p><a href="https://geti2p.net/spec/common-structures#type-signingpublickey">https://geti2p.net/spec/common-structures#type-signingpublickey</a></p>
</dd>
<dt>[SipHash]</dt>
<dd>
<p><a href="https://www.131002.net/siphash/">https://www.131002.net/siphash/</a></p>
</dd>
<dt>[SSU]</dt>
<dd>
<p><a href="https://geti2p.net/en/docs/transport/ssu">https://geti2p.net/en/docs/transport/ssu</a></p>
</dd>
<dt>[STS]</dt>
<dd>
<p>Diffie, W.; van Oorschot P. C.; Wiener M. J., Authentication and
Authenticated Key Exchanges</p>
</dd>
<dt>[Ticket1112]</dt>
<dd>
<p><a href="https://trac.i2p2.de/ticket/1112">https://trac.i2p2.de/ticket/1112</a></p>
</dd>
<dt>[Ticket1849]</dt>
<dd>
<p><a href="https://trac.i2p2.de/ticket/1849">https://trac.i2p2.de/ticket/1849</a></p>
</dd>
</dl>
<p>[1]
<a href="http://www.chesworkshop.org/ches2009/presentations/01_Session_1/CHES2009_ekasper.pdf">http://www.chesworkshop.org/ches2009/presentations/01_Session_1/CHES2009_ekasper.pdf</a></p>
<p>[2]
<a href="https://www.blackhat.com/docs/us-16/materials/us-16-Devlin-Nonce-Disrespecting-Adversaries-Practical-Forgery-Attacks-On-GCM-In-TLS.pdf">https://www.blackhat.com/docs/us-16/materials/us-16-Devlin-Nonce-Disrespecting-Adversaries-Practical-Forgery-Attacks-On-GCM-In-TLS.pdf</a></p>
<p>[3] <a href="https://eprint.iacr.org/2014/613.pdf">https://eprint.iacr.org/2014/613.pdf</a></p>
<p>[4] <a href="https://www.imperialviolet.org/2013/10/07/chacha20.html">https://www.imperialviolet.org/2013/10/07/chacha20.html</a></p>
<p>[5] <a href="https://tools.ietf.org/html/rfc7539">https://tools.ietf.org/html/rfc7539</a></p>

  </section>
</article>

</main>

</div>

<footer>
  <div class="container">
    <span class="copyright">&copy; 2021 I2P Specifications - <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></span>
  </div>
</footer>

</body>
</html>

