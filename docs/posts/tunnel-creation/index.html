<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta name="description" content="">
<meta name="generator" content="Hugo 0.82.1" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/i2p.spec/css/style.css" type="text/css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type="text/css">
<link rel="alternate" href="/i2p.spec/index.xml" type="application/rss+xml" title="I2P Specifications">
<title>Tunnel Creation - I2P Specifications</title>
</head>
<body>

<header>
  <div class="container clearfix">
    <a class="path" href="https://eyedeekay.github.io/i2p.spec/">[I2P Specifications]</a>
    <span class="caret"># _</span>
    <div class="right">
      
    </div>
  </div>
</header>

<div class="container">


<main role="main" class="article">
  
<article class="single" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2021-04-27">April 27, 2021</time></span>



  </div>
  <h1 class="headline" itemprop="headline">Tunnel Creation</h1>
  <section class="body" itemprop="articleBody">
    <h1 id="tunnel-creation-specification">Tunnel Creation Specification</h1>
<p>Category: Design Last updated: July 2019 Accurate for: 0.9.41</p>
<h2 id="tunnelCreate" class="overview">Overview</h2>
<p>This document specifies the details of the encrypted tunnel build
messages used to create tunnels using a &quot;non-interactive telescoping&quot;
method. See the tunnel build document [TUNNEL-IMPL] for an overview of
the process, including peer selection and ordering methods.</p>
<p>The tunnel creation is accomplished by a single message passed along the
path of peers in the tunnel, rewritten in place, and transmitted back to
the tunnel creator. This single tunnel message is made up of a variable
number of records (up to 8) - one for each potential peer in the tunnel.
Individual records are asymmetrically (ElGamal [CRYPTO-ELG] )
encrypted to be read only by a specific peer along the path, while an
additional symmetric layer of encryption (AES [CRYPTO-AES] ) is added
at each hop so as to expose the asymmetrically encrypted record only at
the appropriate time.</p>
<h3 id="number">Number of Records</h3>
<p>Not all records must contain valid data. The build message for a 3-hop
tunnel, for example, may contain more records to hide the actual length
of the tunnel from the participants. There are two build message types.
The original Tunnel Build Message ([TBM] ) contains 8 records, which
is more than enough for any practical tunnel length. The newer Variable
Tunnel Build Message ([VTBM] ) contains 1 to 8 records. The originator
may trade off the size of the message with the desired amount of tunnel
length obfuscation.</p>
<p>In the current network, most tunnels are 2 or 3 hops long. The current
implementation uses a 5-record VTBM to build tunnels of 4 hops or less,
and the 8-record TBM for longer tunnels. The 5-record VTBM (which, when
fragmented, fits in three 1KB tunnel messaages) reduces network traffic
and increases build sucess rate, because smaller messages are less
likely to be dropped.</p>
<p>The reply message must be the same type and length as the build message.</p>
<h3 id="tunnelCreate" class="requestRecord">Request Record Specification</h3>
<p>Also specified in the I2NP Specification [BRR].</p>
<p>Cleartext of the record, visible only to the hop being asked:</p>
<pre><code>bytes     0-3: tunnel ID to receive messages as, nonzero
bytes    4-35: local router identity hash
bytes   36-39: next tunnel ID, nonzero
bytes   40-71: next router identity hash
bytes  72-103: AES-256 tunnel layer key
bytes 104-135: AES-256 tunnel IV key
bytes 136-167: AES-256 reply key
bytes 168-183: AES-256 reply IV
byte      184: flags
bytes 185-188: request time (in hours since the epoch, rounded down)
bytes 189-192: next message ID
bytes 193-221: uninterpreted / random padding
</code></pre>
<p>The next tunnel ID and next router identity hash fields are used to
specify the next hop in the tunnel, though for an outbound tunnel
endpoint, they specify where the rewritten tunnel creation reply message
should be sent. In addition, the next message ID specifies the message
ID that the message (or reply) should use.</p>
<p>The tunnel layer key, tunnel IV key, reply key, and reply IV are each
random 32-byte values generated by the creator, for use in this build
request record only.</p>
<p>The flags field contains the following:</p>
<pre><code>Bit order: 76543210 (bit 7 is MSB)
bit 7: if set, allow messages from anyone
bit 6: if set, allow messages to anyone, and send the reply to the
       specified next hop in a Tunnel Build Reply Message
bits 5-0: Undefined, must set to 0 for compatibility with future options
</code></pre>
<p>Bit 7 indicates that the hop will be an inbound gateway (IBGW). Bit 6
indicates that the hop will be an outbound endpoint (OBEP). If neither
bit is set, the hop will be an intermediate participant. Both cannot be
set at once.</p>
<h4 id="request-record-creation">Request Record Creation</h4>
<p>Every hop gets a random Tunnel ID, nonzero. The current and next-hop
Tunnel IDs are filled in. Every record gets a random tunnel IV key,
reply IV, layer key, and reply key.</p>
<h4 id="encryption">Request Record Encryption</h4>
<p>That cleartext record is ElGamal 2048 encrypted [CRYPTO-ELG] with the
hop's public encryption key and formatted into a 528 byte record:</p>
<pre><code>bytes   0-15: First 16 bytes of the SHA-256 of the current hop's router identity
bytes 16-527: ElGamal-2048 encrypted request record
</code></pre>
<p>In the 512-byte encrypted record, the ElGamal data contains bytes 1-256
and 258-513 of the 514-byte ElGamal encrypted block [CRYPTO-ELG]. The
two padding bytes from the block (the zero bytes at locations 0 and 257)
are removed.</p>
<p>Since the cleartext uses the full field, there is no need for additional
padding beyond <code>SHA256(cleartext) + cleartext</code>.</p>
<p>Each 528-byte record is then iteratively encrypted (using AES
decryption, with the reply key and reply IV for each hop) so that the
router identity will only be in cleartext for the hop in question.</p>
<h3 id="tunnelCreate" class="hopProcessing">Hop Processing and Encryption</h3>
<p>When a hop receives a TunnelBuildMessage, it looks through the records
contained within it for one starting with their own identity hash
(trimmed to 16 bytes). It then decrypts the ElGamal block from that
record and retrieves the protected cleartext. At that point, they make
sure the tunnel request is not a duplicate by feeding the AES-256 reply
key into a Bloom filter. Duplicates or invalid requests are dropped.
Records that are not stamped with the current hour, or the previous hour
if shortly after the top of the hour, must be dropped. For example, take
the hour in the timestamp, convert to a full time, then if it's more
than 65 minutes behind or 5 minutes ahead of the current time, it is
invalid. The Bloom filter must have a duration of at least one hour
(plus a few minutes, to allow for clock skew), so that duplicate records
in the current hour that are not rejected by checking the hour timestamp
in the record, will be rejected by the filter.</p>
<p>After deciding whether they will agree to participate in the tunnel or
not, they replace the record that had contained the request with an
encrypted reply block. All other records are AES-256 encrypted
[CRYPTO-AES] with the included reply key and IV. Each is AES/CBC
encrypted separately with the same reply key and reply IV. The CBC mode
is not continued (chained) across records.</p>
<p>Each hop knows only its own response. If it agrees, it will maintain the
tunnel until expiration, even if it will not be used, as it cannot know
whether all other hops agreed.</p>
<h4 id="tunnelCreate" class="replyRecord">Reply Record Specification</h4>
<p>After the current hop reads their record, they replace it with a reply
record stating whether or not they agree to participate in the tunnel,
and if they do not, they classify their reason for rejection. This is
simply a 1 byte value, with 0x0 meaning they agree to participate in the
tunnel, and higher values meaning higher levels of rejection.</p>
<p>The following rejection codes are defined:</p>
<ul>
<li>TUNNEL_REJECT_PROBABALISTIC_REJECT = 10</li>
<li>TUNNEL_REJECT_TRANSIENT_OVERLOAD = 20</li>
<li>TUNNEL_REJECT_BANDWIDTH = 30</li>
<li>TUNNEL_REJECT_CRIT = 50</li>
</ul>
<p>To hide other causes, such as router shutdown, from peers, the current
implementation uses TUNNEL_REJECT_BANDWIDTH for almost all rejections.</p>
<p>The reply is encrypted with the AES session key delivered to it in the
encrypted block, padded with 495 bytes of random data to reach the full
record size. The padding is placed before the status byte:</p>
<pre><code>AES-256-CBC(SHA-256(padding+status) + padding + status, key, IV)

bytes   0-31 : SHA-256 of bytes 32-527
bytes 32-526 : Random padding
byte 527     : Reply value
</code></pre>
<p>This is also described in the I2NP spec [BRR].</p>
<h3 id="tunnelCreate" class="requestPreparation">Tunnel Build Message Preparation</h3>
<p>When building a new Tunnel Build Message, all of the Build Request
Records must first be built and asymmetrically encrypted using ElGamal
[CRYPTO-ELG]. Each record is then premptively decrypted with the reply
keys and IVs of the hops earlier in the path, using AES [CRYPTO-AES].
That decryption should be run in reverse order so that the
asymmetrically encrypted data will show up in the clear at the right hop
after their predecessor encrypts it.</p>
<p>The excess records not needed for individual requests are simply filled
with random data by the creator.</p>
<h3 id="tunnelCreate" class="requestDelivery">Tunnel Build Message Delivery</h3>
<p>For outbound tunnels, the delivery is done directly from the tunnel
creator to the first hop, packaging up the TunnelBuildMessage as if the
creator was just another hop in the tunnel. For inbound tunnels, the
delivery is done through an existing outbound tunnel. The outbound
tunnel is generally from the same pool as the new tunnel being built. If
no outbound tunnel is available in that pool, an outbound exploratory
tunnel is used. At startup, when no outbound exploratory tunnel exists
yet, a fake 0-hop outbound tunnel is used.</p>
<h3 id="tunnelCreate" class="endpointHandling">Tunnel Build Message Endpoint Handling</h3>
<p>For creation of an outbound tunnel, when the request reaches an outbound
endpoint (as determined by the 'allow messages to anyone' flag), the
hop is processed as usual, encrypting a reply in place of the record and
encrypting all of the other records, but since there is no 'next hop'
to forward the TunnelBuildMessage on to, it instead places the encrypted
reply records into a TunnelBuildReplyMessage ([TBRM] ) or
VariableTunnelBuildReplyMessage ([VTBRM] ) (the type of message and
number of records must match that of the request) and delivers it to the
reply tunnel specified within the request record. That reply tunnel
forwards the Tunnel Build Reply Message back to the tunnel creator, just
as for any other message [TUNNEL-OP]. The tunnel creator then
processes it, as described below.</p>
<p>The reply tunnel was selected by the creator as follows: Generally it is
an inbound tunnel from the same pool as the new outbound tunnel being
built. If no inbound tunnel is available in that pool, an inbound
exploratory tunnel is used. At startup, when no inbound exploratory
tunnel exists yet, a fake 0-hop inbound tunnel is used.</p>
<p>For creation of an inbound tunnel, when the request reaches the inbound
endpoint (also known as the tunnel creator), there is no need to
generate an explicit Tunnel Build Reply Message, and the router
processes each of the replies, as below.</p>
<h3 id="tunnelCreate" class="replyProcessing">Tunnel Build Reply Message Processing</h3>
<p>To process the reply records, the creator simply has to AES decrypt each
record individually, using the reply key and IV of each hop in the
tunnel after the peer (in reverse order). This then exposes the reply
specifying whether they agree to participate in the tunnel or why they
refuse. If they all agree, the tunnel is considered created and may be
used immediately, but if anyone refuses, the tunnel is discarded.</p>
<p>The agreements and rejections are noted in each peer's profile
[PEER-SELECTION], to be used in future assessments of peer tunnel
capacity.</p>
<h2 id="tunnelCreate" class="notes">History and Notes</h2>
<p>This strategy came about during a discussion on the I2P mailing list
between Michael Rogers, Matthew Toseland (toad), and jrandom regarding
the predecessor attack. See [TUNBUILD-SUMMARY],
[TUNBUILD-REASONING]. It was introduced in release 0.6.1.10 on
2006-02-16, which was the last time a non-backward-compatible change was
made in I2P.</p>
<p>Notes:</p>
<ul>
<li>This design does not prevent two hostile peers within a tunnel from
tagging one or more request or reply records to detect that they are
within the same tunnel, but doing so can be detected by the tunnel
creator when reading the reply, causing the tunnel to be marked as
invalid.</li>
<li>This design does not include a proof of work on the asymmetrically
encrypted section, though the 16 byte identity hash could be cut in
half with the latter replaced by a hashcash function of up to 2^64
cost.</li>
<li>This design alone does not prevent two hostile peers within a tunnel
from using timing information to determine whether they are in the
same tunnel. The use of batched and synchronized request delivery
could help (batching up requests and sending them off on the
(ntp-synchronized) minute). However, doing so lets peers 'tag' the
requests by delaying them and detecting the delay later in the
tunnel, though perhaps dropping requests not delivered in a small
window would work (though doing that would require a high degree of
clock synchronization). Alternately, perhaps individual hops could
inject a random delay before forwarding on the request?</li>
<li>Are there any nonfatal methods of tagging the request?</li>
<li>The timestamp with a one-hour resolution is used for replay
prevention. The constraint was not enforced until release 0.9.16.</li>
</ul>
<h2 id="future">Future Work</h2>
<ul>
<li>In the current implementation, the originator leaves one record
empty for itself. Thus a message of n records can only build a
tunnel of n-1 hops. This appears to be necessary for inbound tunnels
(where the next-to-last hop can see the hash prefix for the next
hop), but not for outbound tunnels. This is to be researched and
verified. If it is possible to use the remaining record without
compromising anonymity, we should do so.</li>
<li>Further analysis of possible tagging and timing attacks described in
the above notes.</li>
<li>Use only VTBM; do not select old peers that don't support it.</li>
<li>The Build Request Record does not specify a tunnel lifetime or
expiration; each hop expires the tunnel after 10 minutes, which is a
network-wide hardcoded constant. We could use a bit in the flag
field and take 4 (or 8) bytes out of the padding to specify a
lifetime or expiration. The requestor would only specify this option
if all participants supported it.</li>
</ul>
<h2 id="ref">References</h2>
<dl>
<dt>[BRR]</dt>
<dd>
<p><a href="https://geti2p.net/spec/i2np#struct-buildrequestrecord">https://geti2p.net/spec/i2np#struct-buildrequestrecord</a></p>
</dd>
<dt>[CRYPTO-AES]</dt>
<dd>
<p><a href="https://geti2p.net/en/docs/how/cryptography#AES">https://geti2p.net/en/docs/how/cryptography#AES</a></p>
</dd>
<dt>[CRYPTO-ELG]</dt>
<dd>
<p><a href="https://geti2p.net/en/docs/how/cryptography#elgamal">https://geti2p.net/en/docs/how/cryptography#elgamal</a></p>
</dd>
<dt>[HASHING-IT-OUT]</dt>
<dd>
<p><a href="http://www-users.cs.umn.edu/~hopper/hashing_it_out.pdf">http://www-users.cs.umn.edu/~hopper/hashing_it_out.pdf</a></p>
</dd>
<dt>[PEER-SELECTION]</dt>
<dd>
<p><a href="https://geti2p.net/en/docs/how/peer-selection">https://geti2p.net/en/docs/how/peer-selection</a></p>
</dd>
<dt>[PREDECESSOR]</dt>
<dd>
<p><a href="http://forensics.umass.edu/pubs/wright-tissec.pdf">http://forensics.umass.edu/pubs/wright-tissec.pdf</a></p>
</dd>
<dt>[PREDECESSOR-2008]</dt>
<dd>
<p><a href="http://forensics.umass.edu/pubs/wright.tissec.2008.pdf">http://forensics.umass.edu/pubs/wright.tissec.2008.pdf</a></p>
</dd>
<dt>[TBM]</dt>
<dd>
<p><a href="https://geti2p.net/spec/i2np#msg-tunnelbuild">https://geti2p.net/spec/i2np#msg-tunnelbuild</a></p>
</dd>
<dt>[TBRM]</dt>
<dd>
<p><a href="https://geti2p.net/spec/i2np#msg-tunnelbuildreply">https://geti2p.net/spec/i2np#msg-tunnelbuildreply</a></p>
</dd>
<dt>[TUNBUILD-REASONING]</dt>
<dd>
<p><a href="http://zzz.i2p/archive/2005-10/msg00129.html">http://zzz.i2p/archive/2005-10/msg00129.html</a></p>
</dd>
<dt>[TUNBUILD-SUMMARY]</dt>
<dd>
<p><a href="http://zzz.i2p/archive/2005-10/msg00138.html">http://zzz.i2p/archive/2005-10/msg00138.html</a></p>
</dd>
<dt>[TUNNEL-IMPL]</dt>
<dd>
<p><a href="https://geti2p.net/en/docs/tunnels/implementation">https://geti2p.net/en/docs/tunnels/implementation</a></p>
</dd>
<dt>[TUNNEL-OP]</dt>
<dd>
<p><a href="https://geti2p.net/en/docs/tunnels/implementation#tunnel.operation">https://geti2p.net/en/docs/tunnels/implementation#tunnel.operation</a></p>
</dd>
<dt>[VTBM]</dt>
<dd>
<p><a href="https://geti2p.net/spec/i2np#msg-variabletunnelbuild">https://geti2p.net/spec/i2np#msg-variabletunnelbuild</a></p>
</dd>
<dt>[VTBRM]</dt>
<dd>
<p><a href="https://geti2p.net/spec/i2np#msg-variabletunnelbuildreply">https://geti2p.net/spec/i2np#msg-variabletunnelbuildreply</a></p>
</dd>
</dl>

  </section>
</article>

</main>

</div>

<footer>
  <div class="container">
    <span class="copyright">&copy; 2021 I2P Specifications - <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></span>
  </div>
</footer>

</body>
</html>

