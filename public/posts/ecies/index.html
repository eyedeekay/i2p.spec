<!DOCTYPE html>
<html lang="en-us">
  <head>
    

<meta property="og:title" content="Ecies" />
<meta property="og:description" content="ECIES-X25519-AEAD-Ratchet Category: Protocols Last updated: 2020-11 Accurate for: 0.9.47
Note Network deployment and testing in progress. Subject to minor revisions. See [Prop144] for the original proposal, including background discussion and additional information.
The following features are not implemented as of 0.9.46:
 MessageNumbers, Options, and Termination blocks Protocol-layer responses Zero static key Multicast  Overview This is the new end-to-end encryption protocol to replace ElGamal/AES&#43;SessionTags [ElG-AES].
It relies on previous work as follows:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://eyedeekay.github.io/i2p.spec/posts/ecies/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-27T14:39:35-04:00" />
<meta property="article:modified_time" content="2021-04-27T14:39:35-04:00" />



<meta name="description" content="I2P SPecifications" />
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>I2P Specifications</title>
    
<link rel="icon" type="image/png" href="/i2p.spec/images/favicon.png" />
<link href="https://fonts.googleapis.com/css?family=Open&#43;Sans:400,600" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="/i2p.spec/style.sass" integrity="">
<link rel="stylesheet" type="text/css" href="/i2p.spec/css/icons.css">

  </head>
  <body>
    
    <div id="preloader">
      <div id="status"></div>
    </div>

    

    

<nav class="navbar is-fresh is-transparent no-shadow" role="navigation" aria-label="main navigation">
  <div class="container">
    <div class="navbar-brand">
      <a class="navbar-item" href="/">
        <img src="/i2p.spec/images/logos/fresh.svg" alt="" width="112" height="28">
      </a>
      <a class="navbar-item is-hidden-desktop is-hidden-tablet">
        <div id="menu-icon-wrapper" class="menu-icon-wrapper" style="visibility: visible;">
          <svg width="1000px" height="1000px">
            <path class="path1" d="M 300 400 L 700 400 C 900 400 900 750 600 850 A 400 400 0 0 1 200 200 L 800 800"></path>
            <path class="path2" d="M 300 500 L 700 500"></path>
            <path class="path3" d="M 700 600 L 300 600 C 100 600 100 200 400 150 A 400 380 0 1 1 200 800 L 800 200"></path>
          </svg>
          <button id="menu-icon-trigger" class="menu-icon-trigger"></button>
        </div>
      </a>

      <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbar-menu">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

      <div id="navbar-menu" class="navbar-menu is-static">
        <div class="navbar-start">
          <a class="navbar-item is-hidden-mobile">
            <div id="menu-icon-wrapper" class="menu-icon-wrapper" style="visibility: visible;">
              <svg width="1000px" height="1000px">
                <path class="path1" d="M 300 400 L 700 400 C 900 400 900 750 600 850 A 400 400 0 0 1 200 200 L 800 800"></path>
                <path class="path2" d="M 300 500 L 700 500"></path>
                <path class="path3" d="M 700 600 L 300 600 C 100 600 100 200 400 150 A 400 380 0 1 1 200 800 L 800 200"></path>
              </svg>
              <button id="menu-icon-trigger" class="menu-icon-trigger"></button>
            </div>
          </a>
        </div>

        <div class="navbar-end">
          <a href="/" class="navbar-item is-secondary">
            Features
          </a>
          <a href="/" class="navbar-item is-secondary">
            Pricing
          </a>
          <div class="navbar-item has-dropdown is-hoverable">
            <a class="navbar-link">
              Dropdown
            </a>

            <div class="navbar-dropdown">
              <a href="/" class="navbar-item">
                Dropdown item
              </a>
              <a href="/" class="navbar-item">
                Dropdown item
              </a>
              <a href="/" class="navbar-item">
                Dropdown item
              </a>
            </div>
          </div>
          <a href="/" class="navbar-item is-secondary">
            Log in
          </a>
          <a href="/" class="navbar-item">
            <span class="button signup-button rounded secondary-btn raised">
              Sign up
            </span>
          </a>
        </div>
      </div>
  </div>
</nav>



<nav id="navbar-clone" class="navbar is-fresh is-transparent" role="navigation" aria-label="main navigation">
  <div class="container">
    <div class="navbar-brand">
      <a class="navbar-item" href="/">
        <img src="/i2p.spec/images/logos/fresh.svg" alt="" width="112" height="28">
      </a>
      <a class="navbar-item is-hidden-desktop is-hidden-tablet">
        <div id="menu-icon-wrapper" class="menu-icon-wrapper" style="visibility: visible;">
          <svg width="1000px" height="1000px">
            <path class="path1" d="M 300 400 L 700 400 C 900 400 900 750 600 850 A 400 400 0 0 1 200 200 L 800 800"></path>
            <path class="path2" d="M 300 500 L 700 500"></path>
            <path class="path3" d="M 700 600 L 300 600 C 100 600 100 200 400 150 A 400 380 0 1 1 200 800 L 800 200"></path>
          </svg>
          <button id="menu-icon-trigger" class="menu-icon-trigger"></button>
        </div>
      </a>

      <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="cloned-navbar-menu">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

    <div id="cloned-navbar-menu" class="navbar-menu is-fixed">
      <div class="navbar-start">
        <a class="navbar-item is-hidden-mobile">
          <div id="cloned-menu-icon-wrapper" class="menu-icon-wrapper" style="visibility: visible;">
            <svg width="1000px" height="1000px">
              <path class="path1" d="M 300 400 L 700 400 C 900 400 900 750 600 850 A 400 400 0 0 1 200 200 L 800 800"></path>
              <path class="path2" d="M 300 500 L 700 500"></path>
              <path class="path3" d="M 700 600 L 300 600 C 100 600 100 200 400 150 A 400 380 0 1 1 200 800 L 800 200"></path>
            </svg>
            <button id="cloned-menu-icon-trigger" class="menu-icon-trigger"></button>
          </div>
        </a>
      </div>

      <div class="navbar-end">
        <a href="/" class="navbar-item is-secondary">
          Features
        </a>
        <a href="/" class="navbar-item is-secondary">
          Pricing
        </a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link">
            Dropdown
          </a>

          <div class="navbar-dropdown">
            <a href="/" class="navbar-item">
              Dropdown item
            </a>
            <a href="/" class="navbar-item">
              Dropdown item
            </a>
            <a href="/" class="navbar-item">
              Dropdown item
            </a>
          </div>
        </div>
        <a href="/" class="navbar-item is-secondary">
          Log in
        </a>
        <a href="/" class="navbar-item">
          <span class="button signup-button rounded secondary-btn raised">
            Sign up
          </span>
        </a>
      </div>
    </div>
</div>
</nav>

<section class="section is-medium">
  <div class="container">
    <div class="columns">
      <div class="column is-centered-tablet-portrait">
        <h1 class="title section-title">Ecies</h1>
        <h5 class="subtitle is-5 is-muted"></h5>
        <div class="divider"></div>
      </div>
    </div>
    <h1 id="ecies-x25519-aead-ratchet">ECIES-X25519-AEAD-Ratchet</h1>
<p>Category: Protocols Last updated: 2020-11 Accurate for: 0.9.47</p>
<h2 id="note">Note</h2>
<p>Network deployment and testing in progress. Subject to minor revisions.
See [Prop144] for the original proposal, including background
discussion and additional information.</p>
<p>The following features are not implemented as of 0.9.46:</p>
<ul>
<li>MessageNumbers, Options, and Termination blocks</li>
<li>Protocol-layer responses</li>
<li>Zero static key</li>
<li>Multicast</li>
</ul>
<h2 id="overview">Overview</h2>
<p>This is the new end-to-end encryption protocol to replace
ElGamal/AES+SessionTags [ElG-AES].</p>
<p>It relies on previous work as follows:</p>
<ul>
<li>Common structures spec [Common]</li>
<li>[I2NP] spec including LS2</li>
<li>ElGamal/AES+Session Tags [Elg-AES]</li>
<li><a href="http://zzz.i2p/topics/1768">http://zzz.i2p/topics/1768</a> new asymmetric crypto overview</li>
<li>Low-level crypto overview [CRYPTO-ELG]</li>
<li>ECIES <a href="http://zzz.i2p/topics/2418">http://zzz.i2p/topics/2418</a></li>
<li>[NTCP2] [Prop111]</li>
<li>123 New netDB Entries</li>
<li>142 New Crypto Template</li>
<li>[Noise] protocol</li>
<li>[Signal] double ratchet algorithm</li>
</ul>
<p>It supports new encryption for end-to-end, destination-to-destination
communication.</p>
<p>The design uses a Noise handshake and data phase incorporating Signal's
double ratchet.</p>
<p>All references to Signal and Noise in this specification are for
background information only. Knowledge of Signal and Noise protocols is
not required to understand or implement this specification.</p>
<p>This specification is supported as of version 0.9.46.</p>
<h2 id="specification">Specification</h2>
<p>The design uses a Noise handshake and data phase incorporating Signal's
double ratchet.</p>
<h3 id="summary-of-cryptographic-design">Summary of Cryptographic Design</h3>
<p>There are five portions of the protocol to be redesigned:</p>
<ul>
<li>1) The new and Existing Session container formats are replaced with
new formats.</li>
<li>2) ElGamal (256 byte public keys, 128 byte private keys) is be
replaced with ECIES-X25519 (32 byte public and private keys)</li>
<li>3) AES is be replaced with AEAD_ChaCha20_Poly1305 (abbreviated as
ChaChaPoly below)</li>
<li>4) SessionTags will be replaced with ratchets, which is essentially
a cryptographic, synchronized PRNG.</li>
<li>5) The AES payload, as defined in the ElGamal/AES+SessionTags
specification, is replaced with a block format similar to that in
NTCP2.</li>
</ul>
<p>Each of the five changes has its own section below.</p>
<h3 id="crypto-type">Crypto Type</h3>
<p>The crypto type (used in the LS2) is 4. This indicates a little-endian
32-byte X25519 public key, and the end-to-end protocol specified here.</p>
<p>Crypto type 0 is ElGamal. Crypto types 1-3 are reserved for
ECIES-ECDH-AES-SessionTag, see proposal 145 [Prop145].</p>
<h3 id="noise-protocol-framework">Noise Protocol Framework</h3>
<p>This protocol provides the requirements based on the Noise Protocol
Framework [NOISE] (Revision 34, 2018-07-11). Noise has similar
properties to the Station-To-Station protocol [STS], which is the
basis for the [SSU] protocol. In Noise parlance, Alice is the
initiator, and Bob is the responder.</p>
<p>This specification is based on the Noise protocol
Noise_IK_25519_ChaChaPoly_SHA256. (The actual identifier for the
initial key derivation function is
&quot;Noise_IKelg2_25519_ChaChaPoly_SHA256&quot; to indicate I2P extensions</p>
<ul>
<li>
<p>see KDF 1 section below) This Noise protocol uses the following
primitives:</p>
</li>
<li>
<p>Interactive Handshake Pattern: IK Alice immediately transmits her
static key to Bob (I) Alice knows Bob's static key already (K)</p>
</li>
<li>
<p>One-Way Handshake Pattern: N Alice does not transmit her static key
to Bob (N)</p>
</li>
<li>
<p>DH Function: X25519 X25519 DH with a key length of 32 bytes as
specified in [RFC-7748].</p>
</li>
<li>
<p>Cipher Function: ChaChaPoly AEAD_CHACHA20_POLY1305 as specified in
[RFC-7539] section 2.8. 12 byte nonce, with the first 4 bytes set
to zero. Identical to that in [NTCP2].</p>
</li>
<li>
<p>Hash Function: SHA256 Standard 32-byte hash, already used
extensively in I2P.</p>
</li>
</ul>
<h4 id="additions-to-the-framework">Additions to the Framework</h4>
<p>This specification defines the following enhancements to
Noise_IK_25519_ChaChaPoly_SHA256. These generally follow the
guidelines in [NOISE] section 13.</p>
<ol>
<li>Cleartext ephemeral keys are encoded with [Elligator2].</li>
<li>The reply is prefixed with a cleartext tag.</li>
<li>The payload format is defined for messages 1, 2, and the data phase.
Of course, this is not defined in Noise.</li>
</ol>
<p>All messages include an [I2NP] Garlic Message header. The data phase
uses encryption similar to, but not compatible with, the Noise data
phase.</p>
<h3 id="handshake-patterns">Handshake Patterns</h3>
<p>Handshakes use [Noise] handshake patterns.</p>
<p>The following letter mapping is used:</p>
<ul>
<li>e = one-time ephemeral key</li>
<li>s = static key</li>
<li>p = message payload</li>
</ul>
<p>One-time and Unbound sessions are similar to the Noise N pattern.</p>
<blockquote>
<p>&lt;- s ... e es p -&gt;</p>
</blockquote>
<p>Bound sessions are similar to the Noise IK pattern.</p>
<blockquote>
<p>&lt;- s ... e es s ss p -&gt; &lt;- tag e ee se &lt;- p p -&gt;</p>
</blockquote>
<h3 id="sessions">Sessions</h3>
<p>The ElGamal/AES+SessionTag protocol is unidirectional. At this layer,
the receiver doesn't know where a message is from. Outbound and inbound
sessions are not associated. Acknowledgements are out-of-band using a
DeliveryStatusMessage (wrapped in a GarlicMessage) in the clove.</p>
<p>For this specification, we define two mechanisms to create a
bidirectional protocol -&quot;pairing&quot; and &quot;binding&quot;. These mechanisms
provide increased efficiency and security.</p>
<h4 id="session-context">Session Context</h4>
<p>As with ElGamal/AES+SessionTags, all inbound and outbound sessions must
be in a given context, either the router's context or the context for a
particular local destination. In Java I2P, this context is called the
Session Key Manager.</p>
<p>Sessions must not be shared among contexts, as that would allow
correlation among the various local destinations, or between a local
destination and a router.</p>
<p>When a given destination supports both ElGamal/AES+SessionTags and this
specification, both types of sessions may share a context. See section
1c) below.</p>
<h4 id="pairing-inbound-and-outbound-sessions">Pairing Inbound and Outbound Sessions</h4>
<p>When an outbound session is created at the originator (Alice), a new
inbound session is created and paired with the outbound session, unless
no reply is expected (e.g. raw datagrams).</p>
<p>A new inbound session is always paired with a new outbound session,
unless no reply is requested (e.g. raw datagrams).</p>
<p>If a reply is requested and bound to a far-end destination or router,
that new outbound session is bound to that destination or router, and
replaces any previous outbound session to that destination or router.</p>
<p>Pairing inbound and outbound sessions provides a bidirectional protocol
with the capability of ratcheting the DH keys.</p>
<h4 id="binding-sessions-and-destinations">Binding Sessions and Destinations</h4>
<p>There is only one outbound session to a given destination or router.
There may be several current inbound sessions from a given destination
or router. Generally, when a new inbound session is created, and traffic
is received on that session (which serves as an ACK), any others will be
marked to expire relatively quickly, within a minute or so. The previous
messages sent (PN) value is checked, and if there are no unreceived
messages (within the window size) in the previous inbound session, the
previous session may be deleted immediately.</p>
<p>When an outbound session is created at the originator (Alice), it is
bound to the far-end Destination (Bob), and any paired inbound session
will also be bound to the far-end Destination. As the sessions ratchet,
they continue to be bound to the far-end Destination.</p>
<p>When an inbound session is created at the receiver (Bob), it may be
bound to the far-end Destination (Alice), at Alice's option. If Alice
includes binding information (her static key) in the New Session
message, the session will be bound to that destination, and a outbound
session will be created and bound to same Destination. As the sessions
ratchet, they continue to be bound to the far-end Destination.</p>
<h4 id="benefits-of-binding-and-pairing">Benefits of Binding and Pairing</h4>
<p>For the common, streaming case, we expect Alice and Bob to use the
protocol as follows:</p>
<ul>
<li>Alice pairs her new outbound session to a new inbound session, both
bound to the far-end destination (Bob).</li>
<li>Alice includes the binding information and signature, and a reply
request, in the New Session message sent to Bob.</li>
<li>Bob pairs his new inbound session to a new outbound session, both
bound to the far-end destination (Alice).</li>
<li>Bob sends a reply (ack) to Alice in the paired session, with a
ratchet to a new DH key.</li>
<li>Alice ratchets to a new outbound session with Bob's new key, paired
to the existing inbound session.</li>
</ul>
<p>By binding an inbound session to a far-end Destination, and pairing the
inbound session to an outbound session bound to the same Destination, we
achieve two major benefits:</p>
<ol>
<li>The initial reply from Bob to Alice uses ephemeral-ephemeral DH</li>
</ol>
<p>2) After Alice receives Bob's reply and ratchets, all subsequent
messages from Alice to Bob use ephemeral-ephemeral DH.</p>
<h4 id="message-acks">Message ACKs</h4>
<p>In ElGamal/AES+SessionTags, when a LeaseSet is bundled as a garlic
clove, or tags are delivered, the sending router requests an ACK. This
is a separate garlic clove containing a DeliveryStatus Message. For
additional security, the DeliveryStatus Message is wrapped in a Garlic
Message. This mechanism is out-of-band from the perspective of the
protocol.</p>
<p>In the new protocol, since the inbound and outbound sessions are paired,
we can have ACKs in-band. No separate clove is required.</p>
<p>An explicit ACK is simply an Existing Session message with no I2NP
block. However, in most cases, an explict ACK can be avoided, as there
is reverse traffic. It may be desirable for implementations to wait a
short time (perhaps a hundred ms) before sending an explicit ACK, to
give the streaming or application layer time to respond.</p>
<p>Implementations will also need to defer any ACK sending until after the
I2NP block is processed, as the Garlic Message may contain a Database
Store Message with a lease set. A recent lease set will be necessary to
route the ACK, and the far-end destination (contained in the lease set)
will be necessary to verify the binding static key.</p>
<h4 id="session-timeouts">Session Timeouts</h4>
<p>Outbound sessions should always expire before inbound sessions. One an
outbound session expires, and a new one is created, a new paired inbound
session will be created as well. If there was an old inbound session, it
will be allowed to expire.</p>
<h3 id="multicast">Multicast</h3>
<p>TBD</p>
<h3 id="definitions">Definitions</h3>
<p>We define the following functions corresponding to the cryptographic
building blocks used.</p>
<dl>
<dt>ZEROLEN</dt>
<dd>
<p>zero-length byte array</p>
</dd>
<dt>CSRNG(n)</dt>
<dd>
<p>n-byte output from a cryptographically-secure random number
generator.</p>
</dd>
<dt>H(p, d)</dt>
<dd>
<p>SHA-256 hash function that takes a personalization string p and data
d, and produces an output of length 32 bytes. As defined in
[NOISE]. || below means append.</p>
<p>Use SHA-256 as follows:</p>
<pre><code>H(p, d) := SHA-256(p || d)
</code></pre>
</dd>
<dt>MixHash(d)</dt>
<dd>
<p>SHA-256 hash function that takes a previous hash h and new data d,
and produces an output of length 32 bytes. || below means append.</p>
<p>Use SHA-256 as follows:</p>
<pre><code>MixHash(d) := h = SHA-256(h || d)
</code></pre>
</dd>
<dt>STREAM</dt>
<dd>
<p>The ChaCha20/Poly1305 AEAD as specified in [RFC-7539]. S_KEY_LEN
= 32 and S_IV_LEN = 12.</p>
<dl>
<dt>ENCRYPT(k, n, plaintext, ad)</dt>
<dd>
<p>Encrypts plaintext using the cipher key k, and nonce n which
MUST be unique for the key k. Associated data ad is optional.
Returns a ciphertext that is the size of the plaintext + 16
bytes for the HMAC.</p>
<p>The entire ciphertext must be indistinguishable from random if
the key is secret.</p>
</dd>
<dt>DECRYPT(k, n, ciphertext, ad)</dt>
<dd>
<p>Decrypts ciphertext using the cipher key k, and nonce n.
Associated data ad is optional. Returns the plaintext.</p>
</dd>
</dl>
</dd>
<dt>DH</dt>
<dd>
<p>X25519 public key agreement system. Private keys of 32 bytes, public
keys of 32 bytes, produces outputs of 32 bytes. It has the following
functions:</p>
<dl>
<dt>GENERATE_PRIVATE()</dt>
<dd>
<p>Generates a new private key.</p>
</dd>
<dt>DERIVE_PUBLIC(privkey)</dt>
<dd>
<p>Returns the public key corresponding to the given private key.</p>
</dd>
<dt>GENERATE_PRIVATE_ELG2()</dt>
<dd>
<p>Generates a new private key that maps to a public key suitable
for Elligator2 encoding. Note that half of the
randomly-generated private keys will not be suitable and must be
discarded.</p>
</dd>
<dt>ENCODE_ELG2(pubkey)</dt>
<dd>
<p>Returns the Elligator2-encoded public key corresponding to the
given public key (inverse mapping). Encoded keys are little
endian. Encoded key must be 256 bits indistinguishable from
random data. See Elligator2 section below for specification.</p>
</dd>
<dt>DECODE_ELG2(pubkey)</dt>
<dd>
<p>Returns the public key corresponding to the given
Elligator2-encoded public key. See Elligator2 section below for
specification.</p>
</dd>
<dt>DH(privkey, pubkey)</dt>
<dd>
<p>Generates a shared secret from the given private and public
keys.</p>
</dd>
</dl>
</dd>
<dt>HKDF(salt, ikm, info, n)</dt>
<dd>
<p>A cryptographic key derivation function which takes some input key
material ikm (which should have good entropy but is not required to
be a uniformly random string), a salt of length 32 bytes, and a
context-specific 'info' value, and produces an output of n bytes
suitable for use as key material.</p>
<p>Use HKDF as specified in [RFC-5869], using the HMAC hash function
SHA-256 as specified in [RFC-2104]. This means that SALT_LEN is
32 bytes max.</p>
</dd>
<dt>MixKey(d)</dt>
<dd>
<p>Use HKDF() with a previous chainKey and new data d, and sets the new
chainKey and k. As defined in [NOISE].</p>
<p>Use HKDF as follows:</p>
<pre><code>MixKey(d) := output = HKDF(chainKey, d, &quot;&quot;, 64)
             chainKey = output[0:31]
             k = output[32:63]
</code></pre>
</dd>
</dl>
<h3 id="1-message-format">1) Message format</h3>
<h4 id="review-of-current-message-format">Review of Current Message Format</h4>
<p>The Garlic Message as specified in [I2NP] is as follows. As a design
goal is that intermediate hops cannot distinguish new from old crypto,
this format cannot change, even though the length field is redundant.
The format is shown with the full 16-byte header, although the actual
header may be in a different format, depending on the transport used.</p>
<p>When decrypted the data contains a series of Garlic Cloves and
additional data, also known as a Clove Set.</p>
<p>See [I2NP] for details and a full specification.</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+
msg_id | expiration
+----+----+----+----+----+----+----+----+ |
size +----+----+----+----+----+----+----+----+
| length | | +----+----+----+----+ + | encrypted data
| ~ ~ ~ ~ | |
+----+----+----+----+----+----+----+----+</p>
</blockquote>
<h4 id="review-of-encrypted-data-format">Review of Encrypted Data Format</h4>
<p>In ElGamal/AES+SessionTags, there are two message formats:</p>
<p>1) New session: - 514 byte ElGamal block - AES block (128 bytes
minimum, multiple of 16)</p>
<p>2) Existing session: - 32 byte Session Tag - AES block (128 bytes
minimum, multiple of 16)</p>
<p>These messages are encapsulated in a I2NP garlic message, which contains
a length field, so the length is known.</p>
<p>The receiver first attempts to look up the first 32 bytes as a Session
Tag. If found, he decrypts the AES block. If not found, and the data is
at least (514+16) long, he attempts to decrypt the ElGamal block, and if
successful, decrypts the AES block.</p>
<h4 id="new-session-tags-and-comparison-to-signal">New Session Tags and Comparison to Signal</h4>
<p>In Signal Double Ratchet, the header contains:</p>
<ul>
<li>DH: Current ratchet public key</li>
<li>PN: Previous chain message length</li>
<li>N: Message Number</li>
</ul>
<p>Signal's &quot;sending chains&quot; are roughly equivalent to our tag sets. By
using a session tag, we can eliminate most of that.</p>
<p>In New Session, we put only the public key in the unencrytped header.</p>
<p>In Existing Session, we use a session tag for the header. The session
tag is associated with the current ratchet public key, and the message
number.</p>
<p>In both new and Existing Session, PN and N are in the encrypted body.</p>
<p>In Signal, things are constantly ratcheting. A new DH public key
requires the receiver to ratchet and send a new public key back, which
also serves as the ack for the received public key. This would be far
too many DH operations for us. So we separate the ack of the received
key and the transmission of a new public key. Any message using a
session tag generated from the new DH public key constitutes an ACK. We
only transmit a new public key when we wish to rekey.</p>
<p>The maximum number of messages before the DH must ratchet is 65535.</p>
<p>When delivering a session key, we derive the &quot;Tag Set&quot; from it, rather
than having to deliver session tags as well. A Tag Set can be up to
65536 tags. However, receivers should implement a &quot;look-ahead&quot;
strategy, rather than generating all possible tags at once. Only
generate at most N tags past the last good tag received. N might be at
most 128, but 32 or even less may be a better choice.</p>
<h3 id="1a-new-session-format">1a) New session format</h3>
<p>New Session One Time Public key (32 bytes) Encrypted data and MAC
(remaining bytes)</p>
<p>The New Session message may or may not contain the sender's static
public key. If it is included, the reverse session is bound to that key.
The static key should be included if replies are expected, i.e. for
streaming and repliable datagrams. It should not be included for raw
datagrams.</p>
<p>The New Session message is similar to the one-way Noise [NOISE]
pattern &quot;N&quot; (if the static key is not sent), or the two-way pattern
&quot;IK&quot; (if the static key is sent).</p>
<h3 id="1b-new-session-format-with-binding">1b) New session format (with binding)</h3>
<p>Length is 96 + payload length. Encrypted format:</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
| + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded
with Elligator2 | + + | |
+----+----+----+----+----+----+----+----+ |
| + Static Key + | ChaCha20 encrypted data | + 32 bytes + | | + +
| |
+----+----+----+----+----+----+----+----+ |
Poly1305 Message Authentication Code | + (MAC) for Static Key Section</p>
<ul>
<li>| 16 bytes |
+----+----+----+----+----+----+----+----+ |
| + Payload Section + | ChaCha20 encrypted data | ~ ~ | | + +
| |
+----+----+----+----+----+----+----+----+ |
Poly1305 Message Authentication Code | + (MAC) for Payload Section +
| 16 bytes |
+----+----+----+----+----+----+----+----+</li>
</ul>
<p>Public Key :: 32 bytes, little endian, Elligator2, cleartext</p>
<p>Static data :: 32 bytes</p>
<p>Payload data :: remaining data minus 16 bytes</p>
<p>MAC :: Poly1305 message authentication code, 16 bytes</p>
</blockquote>
<h4 id="new-session-ephemeral-key">New Session Ephemeral Key</h4>
<p>The ephemeral key is 32 bytes, encoded with Elligator2. This key is
never reused; a new key is generated with each message, including
retransmissions.</p>
<h4 id="static-key">Static Key</h4>
<p>When decryptied, Alice's X25519 static key, 32 bytes.</p>
<h4 id="payload">Payload</h4>
<p>Encrypted length is the remainder of the data. Decrypted length is 16
less than the encrypted length. Payload must contain a DateTime block
and will usually contain one or more Garlic Clove blocks. See the
payload section below for format and additional requirements.</p>
<h3 id="1c-new-session-format-without-binding">1c) New session format (without binding)</h3>
<p>If no reply is required, no static key is sent.</p>
<p>Length is 96 + payload length. Encrypted format:</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
| + + | New Session Ephemeral Public Key | + 32 bytes + | Encoded
with Elligator2 | + + | |
+----+----+----+----+----+----+----+----+ |
| + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | |</p>
<ul>
<li>
<ul>
<li>| |
+----+----+----+----+----+----+----+----+ |
Poly1305 Message Authentication Code | + (MAC) for above section + |
16 bytes |
+----+----+----+----+----+----+----+----+ |
| + Payload Section + | ChaCha20 encrypted data | ~ ~ | | + +
| |
+----+----+----+----+----+----+----+----+ |
Poly1305 Message Authentication Code | + (MAC) for Payload Section +
| 16 bytes |
+----+----+----+----+----+----+----+----+</li>
</ul>
</li>
</ul>
<p>Public Key :: 32 bytes, little endian, Elligator2, cleartext</p>
<p>Flags data :: 32 bytes</p>
<p>Payload data :: remaining data minus 16 bytes</p>
<p>MAC :: Poly1305 message authentication code, 16 bytes</p>
</blockquote>
<h4 id="new-session-ephemeral-key-1">New Session Ephemeral Key</h4>
<p>Alice's ephemeral key. The ephemeral key is 32 bytes, encoded with
Elligator2, little endian. This key is never reused; a new key is
generated with each message, including retransmissions.</p>
<h4 id="flags-section-decrypted-data">Flags Section Decrypted data</h4>
<p>The Flags section contains nothing. It is always 32 bytes, because it
must be the same length as the static key for New Session messages with
binding. Bob determines whether it's a static key or a flags section by
testing if the 32 bytes are all zeros.</p>
<p>TODO any flags needed here?</p>
<h4 id="payload-1">Payload</h4>
<p>Encrypted length is the remainder of the data. Decrypted length is 16
less than the encrypted length. Payload must contain a DateTime block
and will usually contain one or more Garlic Clove blocks. See the
payload section below for format and additional requirements.</p>
<h3 id="1d-one-time-format-no-binding-or-session">1d) One-time format (no binding or session)</h3>
<p>If only a single message is expected to be sent, no session setup or
static key is required.</p>
<p>Length is 96 + payload length. Encrypted format:</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
| + + | Ephemeral Public Key | + 32 bytes + | Encoded with
Elligator2 | + + | |
+----+----+----+----+----+----+----+----+ |
| + Flags Section + | ChaCha20 encrypted data | + 32 bytes + | |</p>
<ul>
<li>
<ul>
<li>| |
+----+----+----+----+----+----+----+----+ |
Poly1305 Message Authentication Code | + (MAC) for above section + |
16 bytes |
+----+----+----+----+----+----+----+----+ |
| + Payload Section + | ChaCha20 encrypted data | ~ ~ | | + +
| |
+----+----+----+----+----+----+----+----+ |
Poly1305 Message Authentication Code | + (MAC) for Payload Section +
| 16 bytes |
+----+----+----+----+----+----+----+----+</li>
</ul>
</li>
</ul>
<p>Public Key :: 32 bytes, little endian, Elligator2, cleartext</p>
<p>Flags data :: 32 bytes</p>
<p>Payload data :: remaining data minus 16 bytes</p>
<p>MAC :: Poly1305 message authentication code, 16 bytes</p>
</blockquote>
<h4 id="new-session-one-time-key">New Session One Time Key</h4>
<p>The one time key is 32 bytes, encoded with Elligator2, little endian.
This key is never reused; a new key is generated with each message,
including retransmissions.</p>
<h4 id="flags-section-decrypted-data-1">Flags Section Decrypted data</h4>
<p>The Flags section contains nothing. It is always 32 bytes, because it
must be the same length as the static key for New Session messages with
binding. Bob determines whether it's a static key or a flags section by
testing if the 32 bytes are all zeros.</p>
<p>TODO any flags needed here?</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
| + + | | + All zeros + | 32 bytes | + + | |
+----+----+----+----+----+----+----+----+</p>
<p>zeros:: All zeros, 32 bytes.</p>
</blockquote>
<h4 id="payload-2">Payload</h4>
<p>Encrypted length is the remainder of the data. Decrypted length is 16
less than the encrypted length. Payload must contain a DateTime block
and will usually contain one or more Garlic Clove blocks. See the
payload section below for format and additional requirements.</p>
<h3 id="1f-kdfs-for-new-session-message">1f) KDFs for New Session Message</h3>
<h4 id="kdf-for-initial-chainkey">KDF for Initial ChainKey</h4>
<p>This is standard [NOISE] for IK with a modified protocol name. Note
that we use the same initializer for both the IK pattern (bound
sessions) and for N pattern (unbound sessions).</p>
<p>The protocol name is modified for two reasons. First, to indicate that
the ephemeral keys are encoded with Elligator2, and second, to indicate
that MixHash() is called before the second message to mix in the tag
value.</p>
<blockquote>
<p>This is the &quot;e&quot; message pattern:</p>
<p>// Define protocol_name. Set protocol_name =
&quot;Noise_IKelg2+hs2_25519_ChaChaPoly_SHA256&quot; (40 bytes, US-ASCII
encoded, no NULL termination).</p>
<p>// Define Hash h = 32 bytes h = SHA256(protocol_name);</p>
<p>Define ck = 32 byte chaining key. Copy the h data to ck. Set chainKey
= h</p>
<p>// MixHash(null prologue) h = SHA256(h);</p>
<p>// up until here, can all be precalculated by Alice for all outgoing
connections</p>
</blockquote>
<h4 id="kdf-for-flagsstatic-key-section-encrypted-contents">KDF for Flags/Static Key Section Encrypted Contents</h4>
<blockquote>
<p>This is the &quot;e&quot; message pattern:</p>
<p>// Bob's X25519 static keys // bpk is published in leaseset bsk =
GENERATE_PRIVATE() bpk = DERIVE_PUBLIC(bsk)</p>
<p>// Bob static public key // MixHash(bpk) // || below means append h
= SHA256(h || bpk);</p>
<p>// up until here, can all be precalculated by Bob for all incoming
connections</p>
<p>// Alice's X25519 ephemeral keys aesk = GENERATE_PRIVATE_ELG2()
aepk = DERIVE_PUBLIC(aesk)</p>
<p>// Alice ephemeral public key // MixHash(aepk) // || below means
append h = SHA256(h || aepk);</p>
<p>// h is used as the associated data for the AEAD in the New Session
Message // Retain the Hash h for the New Session Reply KDF // eapk is
sent in cleartext in the // beginning of the New Session message
elg2_aepk = ENCODE_ELG2(aepk) // As decoded by Bob aepk =
DECODE_ELG2(elg2_aepk)</p>
<p>End of &quot;e&quot; message pattern.</p>
<p>This is the &quot;es&quot; message pattern:</p>
<p>// Noise es sharedSecret = DH(aesk, bpk) = DH(bsk, aepk)</p>
<p>// MixKey(DH()) //[chainKey, k] = MixKey(sharedSecret) // ChaChaPoly
parameters to encrypt/decrypt keydata = HKDF(chainKey, sharedSecret,
&quot;&quot;, 64) chainKey = keydata[0:31]</p>
<p>// AEAD parameters k = keydata[32:64] n = 0 ad = h ciphertext =
ENCRYPT(k, n, flags/static key section, ad)</p>
<p>End of &quot;es&quot; message pattern.</p>
<p>This is the &quot;s&quot; message pattern:</p>
<p>// MixHash(ciphertext) // Save for Payload section KDF h = SHA256(h
|| ciphertext)</p>
<p>// Alice's X25519 static keys ask = GENERATE_PRIVATE() apk =
DERIVE_PUBLIC(ask)</p>
<p>End of &quot;s&quot; message pattern.</p>
</blockquote>
<h4 id="kdf-for-payload-section-with-alice-static-key">KDF for Payload Section (with Alice static key)</h4>
<blockquote>
<p>This is the &quot;ss&quot; message pattern:</p>
<p>// Noise ss sharedSecret = DH(ask, bpk) = DH(bsk, apk)</p>
<p>// MixKey(DH()) //[chainKey, k] = MixKey(sharedSecret) // ChaChaPoly
parameters to encrypt/decrypt // chainKey from Static Key Section Set
sharedSecret = X25519 DH result keydata = HKDF(chainKey, sharedSecret,
&quot;&quot;, 64) chainKey = keydata[0:31]</p>
<p>// AEAD parameters k = keydata[32:64] n = 0 ad = h ciphertext =
ENCRYPT(k, n, payload, ad)</p>
<p>End of &quot;ss&quot; message pattern.</p>
<p>// MixHash(ciphertext) // Save for New Session Reply KDF h = SHA256(h
|| ciphertext)</p>
</blockquote>
<h4 id="kdf-for-payload-section-without-alice-static-key">KDF for Payload Section (without Alice static key)</h4>
<p>Note that this is a Noise &quot;N&quot; pattern, but we use the same &quot;IK&quot;
initializer as for bound sessions.</p>
<p>New Session essages can not be identified as containing Alice's static
key or not until the static key is decrypted and inspected to determine
if it contains all zeros. Therefore, the receiver must use the &quot;IK&quot;
state machine for all New Session messages. If the static key is all
zeros, the &quot;ss&quot; message pattern must be skipped.</p>
<blockquote>
<p>chainKey = from Flags/Static key section k = from Flags/Static key
section n = 1 ad = h from Flags/Static key section ciphertext =
ENCRYPT(k, n, payload, ad)</p>
</blockquote>
<h3 id="1g-new-session-reply-format">1g) New Session Reply format</h3>
<p>One or more New Session Replies may be sent in response to a single New
Session message. Each reply is prepended by a tag, which is generated
from a TagSet for the session.</p>
<p>The New Session Reply is in two parts. The first part is the completion
of the Noise IK handshake with a prepended tag. The length of the first
part is 56 bytes. The second part is the data phase payload. The length
of the second part is 16 + payload length.</p>
<p>Total length is 72 + payload length. Encrypted format:</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
Session Tag 8 bytes |
+----+----+----+----+----+----+----+----+ |
| + Ephemeral Public Key + | | + 32 bytes + | Encoded with
Elligator2 | + + | |
+----+----+----+----+----+----+----+----+ |
Poly1305 Message Authentication Code | + (MAC) for Key Section (no
data) + | 16 bytes |
+----+----+----+----+----+----+----+----+ |
| + Payload Section + | ChaCha20 encrypted data | ~ ~ | | + +
| |
+----+----+----+----+----+----+----+----+ |
Poly1305 Message Authentication Code | + (MAC) for Payload Section +
| 16 bytes |
+----+----+----+----+----+----+----+----+</p>
<p>Tag :: 8 bytes, cleartext</p>
<p>Public Key :: 32 bytes, little endian, Elligator2, cleartext</p>
<dl>
<dt>MAC :: Poly1305 message authentication code, 16 bytes</dt>
<dd>Note: The ChaCha20 plaintext data is empty (ZEROLEN)</dd>
</dl>
<p>Payload data :: remaining data minus 16 bytes</p>
<p>MAC :: Poly1305 message authentication code, 16 bytes</p>
</blockquote>
<h4 id="session-tag">Session Tag</h4>
<p>The tag is generated in the Session Tags KDF, as initialized in the DH
Initialization KDF below. This correlates the reply to the session. The
Session Key from the DH Initialization is not used.</p>
<h4 id="new-session-reply-ephemeral-key">New Session Reply Ephemeral Key</h4>
<p>Bob's ephemeral key. The ephemeral key is 32 bytes, encoded with
Elligator2, little endian. This key is never reused; a new key is
generated with each message, including retransmissions.</p>
<h4 id="payload-3">Payload</h4>
<p>Encrypted length is the remainder of the data. Decrypted length is 16
less than the encrypted length. Payload will usually contain one or more
Garlic Clove blocks. See the payload section below for format and
additional requirements.</p>
<h4 id="kdf-for-reply-tagset">KDF for Reply TagSet</h4>
<p>One or more tags are created from the TagSet, which is initialized using
the KDF below, using the chainKey from the New Session message.</p>
<blockquote>
<p>// Generate tagset tagsetKey = HKDF(chainKey, ZEROLEN,
&quot;SessionReplyTags&quot;, 32) tagset_nsr = DH_INITIALIZE(chainKey,
tagsetKey)</p>
</blockquote>
<h4 id="kdf-for-reply-key-section-encrypted-contents">KDF for Reply Key Section Encrypted Contents</h4>
<blockquote>
<p>// Keys from the New Session message // Alice's X25519 keys // apk
and aepk are sent in original New Session message // ask = Alice
private static key // apk = Alice public static key // aesk = Alice
ephemeral private key // aepk = Alice ephemeral public key // Bob's
X25519 static keys // bsk = Bob private static key // bpk = Bob public
static key</p>
<p>// Generate the tag tagsetEntry = tagset_nsr.GET_NEXT_ENTRY() tag =
tagsetEntry.SESSION_TAG</p>
<p>// MixHash(tag) h = SHA256(h || tag)</p>
<p>This is the &quot;e&quot; message pattern:</p>
<p>// Bob's X25519 ephemeral keys besk = GENERATE_PRIVATE_ELG2() bepk
= DERIVE_PUBLIC(besk)</p>
<p>// Bob's ephemeral public key // MixHash(bepk) // || below means
append h = SHA256(h || bepk);</p>
<p>// elg2_bepk is sent in cleartext in the // beginning of the New
Session message elg2_bepk = ENCODE_ELG2(bepk) // As decoded by Bob
bepk = DECODE_ELG2(elg2_bepk)</p>
<p>End of &quot;e&quot; message pattern.</p>
<p>This is the &quot;ee&quot; message pattern:</p>
<p>// MixKey(DH()) //[chainKey, k] = MixKey(sharedSecret) // ChaChaPoly
parameters to encrypt/decrypt // chainKey from original New Session
Payload Section sharedSecret = DH(aesk, bepk) = DH(besk, aepk) keydata
= HKDF(chainKey, sharedSecret, &quot;&quot;, 32) chainKey = keydata[0:31]</p>
<p>End of &quot;ee&quot; message pattern.</p>
<p>This is the &quot;se&quot; message pattern:</p>
<p>// MixKey(DH()) //[chainKey, k] = MixKey(sharedSecret) sharedSecret
= DH(ask, bepk) = DH(besk, apk) keydata = HKDF(chainKey, sharedSecret,
&quot;&quot;, 64) chainKey = keydata[0:31]</p>
<p>// AEAD parameters k = keydata[32:64] n = 0 ad = h ciphertext =
ENCRYPT(k, n, ZEROLEN, ad)</p>
<p>End of &quot;se&quot; message pattern.</p>
<p>// MixHash(ciphertext) h = SHA256(h || ciphertext)</p>
<p>chainKey is used in the ratchet below.</p>
</blockquote>
<h4 id="kdf-for-payload-section-encrypted-contents">KDF for Payload Section Encrypted Contents</h4>
<p>This is like the first Existing Session message, post-split, but without
a separate tag. Additionally, we use the hash from above to bind the
payload to the NSR message.</p>
<blockquote>
<p>// split() keydata = HKDF(chainKey, ZEROLEN, &quot;&quot;, 64) k_ab =
keydata[0:31] k_ba = keydata[32:63] tagset_ab =
DH_INITIALIZE(chainKey, k_ab) tagset_ba = DH_INITIALIZE(chainKey,
k_ba)</p>
<p>// AEAD parameters for New Session Reply payload k = HKDF(k_ba,
ZEROLEN, &quot;AttachPayloadKDF&quot;, 32) n = 0 ad = h ciphertext =
ENCRYPT(k, n, payload, ad)</p>
</blockquote>
<h3 id="notes">Notes</h3>
<p>Multiple NSR messages may be sent in reply, each with unique ephemeral
keys, depending on the size of the response.</p>
<p>Alice and Bob are required to use new ephemeral keys for every NS and
NSR message.</p>
<p>Alice must receive one of Bob's NSR messages before sending Existing
Session (ES) messages, and Bob must receive an ES message from Alice
before sending ES messages.</p>
<p>The <code>chainKey</code> and <code>k</code> from Bob's NSR Payload Section are used as
inputs for the initial ES DH Ratchets (both directions, see DH Ratchet
KDF).</p>
<p>Bob must only retain Existing Sessions for the ES messages received from
Alice. Any other created inbound and outbound sessions (for multiple
NSRs) should be destroyed immediately after receiving Alice's first ES
message for a given session.</p>
<h3 id="1h-existing-session-format">1h) Existing session format</h3>
<p>Session tag (8 bytes) Encrypted data and MAC (see section 3 below)</p>
<h4 id="format">Format</h4>
<p>Encrypted:</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
Session Tag |
+----+----+----+----+----+----+----+----+ |
| + Payload Section + | ChaCha20 encrypted data | ~ ~ | | + +
| |
+----+----+----+----+----+----+----+----+ |
Poly1305 Message Authentication Code | + (MAC) + | 16 bytes |
+----+----+----+----+----+----+----+----+</p>
<p>Session Tag :: 8 bytes, cleartext</p>
<p>Payload data :: remaining data minus 16 bytes</p>
<p>MAC :: Poly1305 message authentication code, 16 bytes</p>
</blockquote>
<h4 id="payload-4">Payload</h4>
<p>Encrypted length is the remainder of the data. Decrypted length is 16
less than the encrypted length. See the payload section below for format
and requirements.</p>
<h4 id="kdf">KDF</h4>
<blockquote>
<p>See AEAD section below.</p>
<p>// AEAD parameters for Existing Session payload k = The 32-byte
session key associated with this session tag n = The message number N
in the current chain, as retrieved from the associated Session Tag. ad
= The session tag, 8 bytes ciphertext = ENCRYPT(k, n, payload, ad)</p>
</blockquote>
<h3 id="2-ecies-x25519">2) ECIES-X25519</h3>
<p>Format: 32-byte public and private keys, little-endian.</p>
<h3 id="2a-elligator2">2a) Elligator2</h3>
<p>In standard Noise handshakes, the initial handshake messages in each
direction start with ephemeral keys that are transmitted in cleartext.
As valid X25519 keys are distinguishable from random, a
man-in-the-middle may distinguish these messages from Existing Session
messages that start with random session tags. In [NTCP2] ([Prop111]
), we used a low-overhead XOR function using the out-of-band static key
to obfuscate the key. However, the threat model here is different; we do
not want to allow any MitM to use any means to confirm the destination
of the traffic, or to distinguish the initial handshake messages from
Existing Session messages.</p>
<p>Therefore, [Elligator2] is used to transform the ephemeral keys in the
New Session and New Session Reply messages so that they are
indistinguishable from uniform random strings.</p>
<h4 id="format-1">Format</h4>
<p>32-byte public and private keys. Encoded keys are little endian.</p>
<p>As defined in [Elligator2], the encoded keys are indistinguishable
from 254 random bits. We require 256 random bits (32 bytes). Therefore,
the encoding and decoding are defined as follows:</p>
<p>Encoding:</p>
<blockquote>
<p>ENCODE_ELG2() Definition</p>
<p>// Encode as defined in Elligator2 specification encodedKey =
encode(pubkey) // OR in 2 random bits to MSB randomByte = CSRNG(1)
encodedKey[31] |= (randomByte &amp; 0xc0)</p>
</blockquote>
<p>Decoding:</p>
<blockquote>
<p>DECODE_ELG2() Definition</p>
<p>// Mask out 2 random bits from MSB encodedKey[31] &amp;= 0x3f // Decode
as defined in Elligator2 specification pubkey = decode(encodedKey)</p>
</blockquote>
<h4 id="notes-1">Notes</h4>
<p>Elligator2 doubles average the key generation time, as half the private
keys result in public keys that are unsuitable for encoding with
Elligator2. Also, the key generation time is unbounded with an
exponential distribution, as the generator must keep retrying utnil a
suitable key pair is found.</p>
<p>This overhead may be managed by doing key generation in advance, in a
separate thread, to keep a pool of suitable keys.</p>
<p>The generator does the ENCODE_ELG2() function to determine suitability.
Therefore, the generator should store the result of ENCODE_ELG2() so it
does not have to be calculated again.</p>
<p>Additionally, the unsuitable keys may be added to the pool of keys used
for [NTCP2], where Elligator2 is not used. The security issues of
doing so is TBD.</p>
<h3 id="3-aead-chachapoly">3) AEAD (ChaChaPoly)</h3>
<p>AEAD using ChaCha20 and Poly1305, same as in [NTCP2]. This corresponds
to [RFC-7539], which is also used similarly in TLS [RFC-7905].</p>
<h4 id="new-session-and-new-session-reply-inputs">New Session and New Session Reply Inputs</h4>
<p>Inputs to the encryption/decryption functions for an AEAD block in a New
Session message:</p>
<blockquote>
<dl>
<dt>k :: 32 byte cipher key</dt>
<dd>See New Session and New Session Reply KDFs above.</dd>
<dt>n :: Counter-based nonce, 12 bytes.</dt>
<dd>n = 0</dd>
<dt>ad :: Associated data, 32 bytes.</dt>
<dd>The SHA256 hash of the preceding data, as output from mixHash()</dd>
</dl>
<p>data :: Plaintext data, 0 or more bytes</p>
</blockquote>
<h4 id="existing-session-inputs">Existing Session Inputs</h4>
<p>Inputs to the encryption/decryption functions for an AEAD block in an
Existing Session message:</p>
<blockquote>
<dl>
<dt>k :: 32 byte session key</dt>
<dd>As looked up from the accompanying session tag.</dd>
<dt>n :: Counter-based nonce, 12 bytes.</dt>
<dd>Starts at 0 and incremented for each message when transmitting.
For the receiver, the value as looked up from the accompanying
session tag. First four bytes are always zero. Last eight bytes
are the message number (n), little-endian encoded. Maximum value
is 65535. Session must be ratcheted when N reaches that value.
Higher values must never be used.</dd>
<dt>ad :: Associated data</dt>
<dd>The session tag</dd>
</dl>
<p>data :: Plaintext data, 0 or more bytes</p>
</blockquote>
<h4 id="encrypted-format">Encrypted Format</h4>
<p>Output of the encryption function, input to the decryption function:</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
| + + | ChaCha20 encrypted data | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+ |
Poly1305 Message Authentication Code | + (MAC) + | 16 bytes |
+----+----+----+----+----+----+----+----+</p>
<p>encrypted data :: Same size as plaintext data, 0 - 65519 bytes</p>
<p>MAC :: Poly1305 message authentication code, 16 bytes</p>
</blockquote>
<h4 id="notes-2">Notes</h4>
<ul>
<li>Since ChaCha20 is a stream cipher, plaintexts need not be padded.
Additional keystream bytes are discarded.</li>
<li>The key for the cipher (256 bits) is agreed upon by means of the
SHA256 KDF. The details of the KDF for each message are in separate
sections below.</li>
<li>ChaChaPoly frames are of known size as they are encapsulated in the
I2NP data message.</li>
<li>For all messages, padding is inside the authenticated data frame.</li>
</ul>
<h4 id="aead-error-handling">AEAD Error Handling</h4>
<p>All received data that fails the AEAD verification must be discarded. No
response is returned.</p>
<h3 id="4-ratchets">4) Ratchets</h3>
<p>We still use session tags, as before, but we use ratchets to generate
them. Session tags also had a rekey option that we never implemented. So
it's like a double ratchet but we never did the second one.</p>
<p>Here we define something similar to Signal's Double Ratchet. The
session tags are generated deterministically and identically on the
receiver and sender sides.</p>
<p>By using a symmetric key/tag ratchet, we eliminate memory usage to store
session tags on the sender side. We also eliminate the bandwidth
consumption of sending tag sets. Receiver side usage is still
significant, but we can reduce it further as we will shrink the session
tag from 32 bytes to 8 bytes.</p>
<p>We do not use header encryption as specified (and optional) in Signal,
we use session tags instead.</p>
<p>By using a DH ratchet, we acheive forward secrecy, which was never
implemented in ElGamal/AES+SessionTags.</p>
<p>Note: The New Session one-time public key is not part of the ratchet,
its sole function is to encrypt Alice's initial DH ratchet key.</p>
<h4 id="message-numbers">Message Numbers</h4>
<p>The Double Ratchet handles lost or out-of-order messages by including in
each message header a tag. The receiver looks up the index of the tag,
this is the message number N. If the message contains a Message Number
block with a PN value, the recipient can delete any tags higher than
that value in the previous tag set, while retaining skipped tags from
the previous tag set in case the skipped messages arrive later.</p>
<h4 id="sample-implementation">Sample Implementation</h4>
<p>We define the following data structures and functions to implement these
ratchets.</p>
<dl>
<dt>TAGSET_ENTRY</dt>
<dd>
<p>A single entry in a TAGSET.</p>
<dl>
<dt>INDEX</dt>
<dd>
<p>An integer index, starting with 0</p>
</dd>
<dt>SESSION_TAG</dt>
<dd>
<p>An identifier to go out on the wire, 8 bytes</p>
</dd>
<dt>SESSION_KEY</dt>
<dd>
<p>A symmetric key, never goes on the wire, 32 bytes</p>
</dd>
</dl>
</dd>
<dt>TAGSET</dt>
<dd>
<p>A collection of TAGSET_ENTRIES.</p>
<dl>
<dt>CREATE(key, n)</dt>
<dd>
<p>Generate a new TAGSET using initial cryptographic key material
of 32 bytes. The associated session identifier is provided. The
initial number of of tags to create is specified; this is
generally 0 or 1 for an outgoing session. LAST_INDEX = -1
EXTEND(n) is called.</p>
</dd>
<dt>EXTEND(n)</dt>
<dd>
<p>Generate n more TAGSET_ENTRIES by calling EXTEND() n times.</p>
</dd>
<dt>EXTEND()</dt>
<dd>
<p>Generate one more TAGSET_ENTRY, unless the maximum number
SESSION_TAGS have already been generated. If LAST_INDEX is
greater than or equal to 65535, return. ++ LAST_INDEX Create a
new TAGSET_ENTRY with the LAST_INDEX value and the calculated
SESSION_TAG. Calls RATCHET_TAG() and (optionally)
RATCHET_KEY(). For inbound sessions, the calculation of the
SESSION_KEY may be deferred and calculated in
GET_SESSION_KEY(). Calls EXPIRE()</p>
</dd>
<dt>EXPIRE()</dt>
<dd>
<p>Remove tags and keys that are too old, or if the TAGSET size
exceeds some limit.</p>
</dd>
<dt>RATCHET_TAG()</dt>
<dd>
<p>Calculates the next SESSION_TAG based on the last SESSION_TAG.</p>
</dd>
<dt>RATCHET_KEY()</dt>
<dd>
<p>Calculates the next SESSION_KEY based on the last SESSION_KEY.</p>
</dd>
<dt>SESSION</dt>
<dd>
<p>The associated session.</p>
</dd>
<dt>CREATION_TIME</dt>
<dd>
<p>When the TAGSET was created.</p>
</dd>
<dt>LAST_INDEX</dt>
<dd>
<p>The last TAGSET_ENTRY INDEX generated by EXTEND().</p>
</dd>
<dt>GET_NEXT_ENTRY()</dt>
<dd>
<p>Used for outgoing sessions only. EXTEND(1) is called if there
are no remaining TAGSET_ENTRIES. If EXTEND(1) did nothing, the
max of 65535 TAGSETS have been used, and return an error.
Returns the next unused TAGSET_ENTRY.</p>
</dd>
<dt>GET_SESSION_KEY(sessionTag)</dt>
<dd>
<p>Used for incoming sessions only. Returns the TAGSET_ENTRY
containing the sessionTag. If found, the TAGSET_ENTRY is
removed. If the SESSION_KEY calculation was deferred, it is
calculated now. If there are few TAGSET_ENTRIES remaining,
EXTEND(n) is called.</p>
</dd>
</dl>
</dd>
</dl>
<h4 id="4a-dh-ratchet">4a) DH Ratchet</h4>
<p>Ratchets but not nearly as fast as Signal does. We separate the ack of
the received key from generating the new key. In typical usage, Alice
and Bob will each ratchet (twice) immediately in a New Session, but will
not ratchet again.</p>
<p>Note that a ratchet is for a single direction, and generates a New
Session tag / message key ratchet chain for that direction. To generate
keys for both directions, you have to ratchet twice.</p>
<p>You ratchet every time you generate and send a new key. You ratchet
every time you receive a new key.</p>
<p>Alice ratchets once when creating an unbound outbound session, she does
not create an inbound session (unbound is non-repliable).</p>
<p>Bob ratchets once when creating an unbound inbound session, and does not
create a corresponding outbound session (unbound is non-repliable).</p>
<p>Alice continues sending New Session (NS) messages to Bob until receiving
one of Bob's New Session Reply (NSR) messages. She then uses the NSR's
Payload Section KDF results as inputs for the session ratchets (see DH
Ratchet KDF), and begins sending Existing Session (ES) messages.</p>
<p>For each NS message received, Bob creates a new inbound session, using
the KDF results of the reply Payload Section for inputs to the new
inbound and outbound ES DH Ratchet.</p>
<p>For each reply required, Bob sends Alice a NSR message with the reply in
the payload. It is required Bob use new ephemeral keys for every NSR.</p>
<p>Bob must receive an ES message from Alice on one of the inbound
sessions, before creating and sending ES messages on the corresponding
outbound session.</p>
<p>Alice should use a timer for receiving a NSR message from Bob. If the
timer expires, the session should be removed.</p>
<p>To avoid a KCI and/or resource exhaustion attack, where an attacker
drops Bob's NSR replies to keep Alice sending NS messages, Alice should
avoid starting New Sessions to Bob after a certain number of retries due
to timer expiration.</p>
<p>Alice and Bob each do a DH ratchet for every NextKey block received.</p>
<p>Alice and Bob each generate new tag setstchets and two symmetric keys
ratchets after each DH ratchet. For each new ES message in a given
direction, Alice and Bob advance the session tag and symmtric key
ratchets.</p>
<p>The frequency of DH ratchets after the initial handshake is
implementation-dependent. While the protocol places a limit of 65535
messages before a ratchet is required, more frequent ratcheting (based
on message count, elapsed time, or both) may provide additional
security.</p>
<p>After the final handshake KDF on bound sessions, Bob and Alice must run
the Noise Split() function on the resulting CipherState to create
independent symmetric and tag chain keys for inbound and outbound
sessions.</p>
<h5 id="key-and-tag-set-ids">KEY AND TAG SET IDS</h5>
<p>Key and tag set ID numbers are used to identify keys and tag sets. Key
IDs are used in NextKey blocks to identify the key sent or used. Tag set
IDs are used (with the message number) in ACK blocks to identify the
message being acked. Both key and tag set IDs apply to the tag sets for
a single direction. Key and tag set ID numbers must be sequential.</p>
<p>In the first tag sets used for a session in each direction, the tag set
ID is 0. No NextKey blocks have been sent, so there are no key IDs.</p>
<p>To begin a DH ratchet, the sender transmits a new NextKey block with a
key ID of 0. The receiver replies with a new NextKey block with a key ID
of 0. The sender then starts using a new tag set with a tag set ID of 1.</p>
<p>Subsequent tag sets are generated similarly. For all tag sets used after
NextKey exchanges, the tag set number is (1 + Alice's key ID + Bob's
key ID).</p>
<p>Key and tag set IDs start at 0 and increment sequentially. The maximum
tag set ID is 65535. The maximum key ID is 32767. When a tag set is
almost exhausted, the tag set sender must initiate a NextKey exchange.
When tag set 65535 is almost exhausted, the tag set sender must initiate
a new session by sending a New Session message.</p>
<p>With a streaming maximum message size of 1730, and assuming no
retransmissions, the theoretical maximum data transfer using a single
tag set is 1730 * 65536 ~= 108 MB. The actual maximum will be lower
due to retransmissions.</p>
<p>The theoretical maximum data transfer with all 65536 available tag sets,
before the session would have to be discarded and replaced, is 64K *
108 MB ~= 6.9 TB.</p>
<h5 id="dh-ratchet-message-flow">DH RATCHET MESSAGE FLOW</h5>
<p>The next key exchange for a tag set must be initiated by the sender of
those tags (the owner of the outbound tag set). The receiver (owner of
the inbound tag set) will respond. For a typical HTTP GET traffic at the
application layer, Bob will send more messages and will ratchet first by
initiating the key exchange; the diagram below shows that. When Alice
ratchets, the same thing happens in reverse.</p>
<p>The first tag set used after the NS/NSR handshake is tag set 0. When tag
set 0 is almost exhausted, new keys must be exchanged in both directions
to create tag set 1. After that, a new key is only sent in one
direction.</p>
<p>To create tag set 2, the tag sender sends a new key and the tag receiver
sends the ID of his old key as an acknowledgement. Both sides do a DH.</p>
<p>To create tag set 3, the tag sender sends the ID of his old key and
requests a new key from the tag receiver. Both sides do a DH.</p>
<p>Subsequent tag sets are generated as for tag sets 2 and 3. The tag set
number is (1 + sender key id + receiver key id).</p>
<blockquote>
<p>Tag Sender Tag Receiver</p>
<blockquote>
<p>... use tag set #0 ...</p>
</blockquote>
<p>(Tagset #0 almost empty) (generate new key #0)</p>
<p>Next Key, forward, request reverse, with key #0 --------&gt;
(repeat until next key received)</p>
<blockquote>
<p>(generate new key #0, do DH, create IB Tagset #1)</p>
<p>&lt;------------- Next Key, reverse, with key #0 (repeat
until tag received on new tagset)</p>
</blockquote>
<p>(do DH, create OB Tagset #1)</p>
<blockquote>
<p>... use tag set #1 ...</p>
</blockquote>
<p>(Tagset #1 almost empty) (generate new key #1)</p>
<p>Next Key, forward, with key #1 --------&gt; (repeat until next
key received)</p>
<blockquote>
<p>(reuse key #0, do DH, create IB Tagset #2)</p>
<p>&lt;-------------- Next Key, reverse, id 0 (repeat until
tag received on new tagset)</p>
</blockquote>
<p>(do DH, create OB Tagset #2)</p>
<blockquote>
<p>... use tag set #2 ...</p>
</blockquote>
<p>(Tagset #2 almost empty) (reuse key #1)</p>
<p>Next Key, forward, request reverse, id 1 --------&gt; (repeat
until next key received)</p>
<blockquote>
<p>(generate new key #1, do DH, create IB Tagset #3)</p>
<p>&lt;-------------- Next Key, reverse, with key #1</p>
</blockquote>
<p>(do DH, create OB Tagset #3) (reuse key #1, do DH, create IB Tagset
#3)</p>
<blockquote>
<p>... use tag set #3 ...</p>
<p>After tag set 3, repeat the above patterns as shown for tag sets 2
and 3.</p>
<p>To create a new even-numbered tag set, the sender sends a new key to
the receiver. The receiver sends his old key ID back as an
acknowledgement.</p>
<p>To create a new odd-numbered tag set, the sender sends a reverse
request to the receiver. The receiver sends a new reverse key to the
sender.</p>
</blockquote>
</blockquote>
<p>After the DH ratchet is complete for an outbound tagset, and a new
outbound tagset is created, it should be used immediately, and the old
outbound tagset may be deleted.</p>
<p>After the DH ratchet is complete for an inbound tagset, and a new
inbound tagset is created, the receiver should listen for tags in both
tagsets, and delete the old tagset after a short time, about 3 minutes.</p>
<p>Summary of tag set and key ID progression is in the table below. *
indicates that a new key is generated.</p>
<p>New Tag Set ID   Sender key ID   Rcvr key ID</p>
<hr>
<p>0                n/a             n/a
1                0 *            0 *
2                1 *            0
3                1               1 *
4                2 *            1
5                2               2 *
...             ...            ...
65534            32767 *        32766
65535            32767           32767 *</p>
<p>Key and tag set ID numbers must be sequential.</p>
<h5 id="dh-initialization-kdf">DH INITIALIZATION KDF</h5>
<p>This is the definition of DH_INITIALIZE(rootKey, k) for a single
direction. It creates a tagset, and a &quot;next root key&quot; to be used for a
subsequent DH ratchet if necessary.</p>
<p>We use DH initialization in three places. First, we use it to generate a
tag set for the New Session Replies. Second, we use it to generate two
tag sets, one for each direction, for use in Existing Session messages.
Lastly, we use it after a DH Ratchet to generate a new tag set in a
single direction for additional Existing Session messages.</p>
<blockquote>
<p>Inputs: 1) rootKey = chainKey from Payload Section 2) k from the New
Session KDF or split()</p>
<p>// KDF_RK(rk, dh_out) keydata = HKDF(rootKey, k,
&quot;KDFDHRatchetStep&quot;, 64)</p>
<p>// Output 1: The next Root Key (KDF input for the next DH ratchet)
nextRootKey = keydata[0:31] // Output 2: The chain key to initialize
the new // session tag and symmetric key ratchets // for the tag set
ck = keydata[32:63]</p>
<p>// session tag and symmetric key chain keys keydata = HKDF(ck,
ZEROLEN, &quot;TagAndKeyGenKeys&quot;, 64) sessTag_ck = keydata[0:31]
symmKey_ck = keydata[32:63]</p>
</blockquote>
<h5 id="dh-ratchet-kdf">DH RATCHET KDF</h5>
<p>This is used after new DH keys are exchanged in NextKey blocks, before a
tagset is exhausted.</p>
<blockquote>
<p>// Tag sender generates new X25519 ephemeral keys // and sends rapk to
tag receiver in a NextKey block rask = GENERATE_PRIVATE() rapk =
DERIVE_PUBLIC(rask)</p>
<p>// Tag receiver generates new X25519 ephemeral keys // and sends rbpk
to Tag sender in a NextKey block rbsk = GENERATE_PRIVATE() rbpk =
DERIVE_PUBLIC(rbsk)</p>
<p>sharedSecret = DH(rask, rbpk) = DH(rbsk, rapk) tagsetKey =
HKDF(sharedSecret, ZEROLEN, &quot;XDHRatchetTagSet&quot;, 32) rootKey =
nextRootKey // from previous tagset in this direction newTagSet =
DH_INITIALIZE(rootKey, tagsetKey)</p>
</blockquote>
<h4 id="4b-session-tag-ratchet">4b) Session Tag Ratchet</h4>
<p>Ratchets for every message, as in Signal. The session tag ratchet is
synchronized with the symmetric key ratchet, but the receiver key
ratchet may &quot;lag behind&quot; to save memory.</p>
<p>Transmitter ratchets once for each message transmitted. No additional
tags must be stored. The transmitter must also keep a counter for 'N',
the message number of the message in the current chain. The 'N' value
is included in the sent message. See the Message Number block
definition.</p>
<p>Receiver must ratchet ahead by the max window size and store the tags in
a &quot;tag set&quot;, which is associated with the session. Once received, the
stored tag may be discarded, and if there are no previous unreceived
tags, the window may be advanced. The receiver should keep the 'N'
value associated with each session tag, and check that the number in the
sent message matches this value. See the Message Number block
definition.</p>
<h5 id="kdf-1">KDF</h5>
<p>This is the definition of RATCHET_TAG().</p>
<blockquote>
<p>Inputs: 1) Session Tag Chain key sessTag_ck First time: output from
DH ratchet Subsequent times: output from previous session tag ratchet</p>
<p>Generated: 2) input_key_material = SESSTAG_CONSTANT Must be unique
for this tag set (generated from chain key), so that the sequence
isn't predictable, since session tags go out on the wire in
plaintext.</p>
<p>Outputs: 1) N (the current session tag number) 2) the session tag (and
symmetric key, probably) 3) the next Session Tag Chain Key (KDF input
for the next session tag ratchet)</p>
<p>Initialization: keydata = HKDF(sessTag_ck, ZEROLEN,
&quot;STInitialization&quot;, 64) // Output 1: Next chain key
sessTag_chainKey = keydata[0:31] // Output 2: The constant
SESSTAG_CONSTANT = keydata[32:63]</p>
<p>// KDF_ST(ck, constant) keydata_0 = HKDF(sessTag_chainkey,
SESSTAG_CONSTANT, &quot;SessionTagKeyGen&quot;, 64) // Output 1: Next chain
key sessTag_chainKey_0 = keydata_0[0:31] // Output 2: The session
tag // or more if tag is longer than 8 bytes tag_0 =
keydata_0[32:39]</p>
<p>// repeat as necessary to get to tag_n keydata_n =
HKDF(<a href="">sessTag_chainKey</a>(n-1), SESSTAG_CONSTANT,
&quot;SessionTagKeyGen&quot;, 64) // Output 1: Next chain key
sessTag_chainKey_n = keydata_n[0:31] // Output 2: The session tag
// or more if tag is longer than 8 bytes tag_n = keydata_n[32:39]</p>
</blockquote>
<h4 id="4c-symmetric-key-ratchet">4c) Symmetric Key Ratchet</h4>
<p>Ratchets for every message, as in Signal. Each symmetric key has an
associated message number and session tag. The session key ratchet is
synchronized with the symmetric tag ratchet, but the receiver key
ratchet may &quot;lag behind&quot; to save memory.</p>
<p>Transmitter ratchets once for each message transmitted. No additional
keys must be stored.</p>
<p>When receiver gets a session tag, if it has not already ratcheted the
symmetric key ratchet ahead to the associated key, it must &quot;catch up&quot;
to the associated key. The receiver will probably cache the keys for any
previous tags that have not yet been received. Once received, the stored
key may be discarded, and if there are no previous unreceived tags, the
window may be advanced.</p>
<p>For efficiency, the session tag and symmetric key ratchets are separate
so the session tag ratchet can run ahead of the symmetric key ratchet.
This also provides some additional security, since the session tags go
out on the wire.</p>
<h5 id="kdf-2">KDF</h5>
<p>This is the definition of RATCHET_KEY().</p>
<blockquote>
<p>Inputs: 1) Symmetric Key Chain key symmKey_ck First time: output from
DH ratchet Subsequent times: output from previous symmetric key
ratchet</p>
<p>Generated: 2) input_key_material = SYMMKEY_CONSTANT = ZEROLEN No
need for uniqueness. Symmetric keys never go out on the wire. TODO:
Set a constant anyway?</p>
<p>Outputs: 1) N (the current session key number) 2) the session key 3)
the next Symmetric Key Chain Key (KDF input for the next symmetric key
ratchet)</p>
<p>// KDF_CK(ck, constant) SYMMKEY_CONSTANT = ZEROLEN // Output 1: Next
chain key keydata_0 = HKDF(symmKey_ck, SYMMKEY_CONSTANT,
&quot;SymmetricRatchet&quot;, 64) symmKey_chainKey_0 = keydata_0[0:31] //
Output 2: The symmetric key k_0 = keydata_0[32:63]</p>
<p>// repeat as necessary to get to k[n] keydata_n =
HKDF(<a href="">symmKey_chainKey</a>(n-1), SYMMKEY_CONSTANT,
&quot;SymmetricRatchet&quot;, 64) // Output 1: Next chain key
symmKey_chainKey_n = keydata_n[0:31] // Output 2: The symmetric
key k_n = keydata_n[32:63]</p>
</blockquote>
<h3 id="5-payload">5) Payload</h3>
<p>This replaces the AES section format defined in the
ElGamal/AES+SessionTags specification.</p>
<p>This uses the same block format as defined in the [NTCP2]
specification. Individual block types are defined differently.</p>
<p>There are concerns that encouraging implementers to share code may lead
to parsing issues. Implementers should carefully consider the benefits
and risks of sharing code, and ensure that the ordering and valid block
rules are different for the two contexts.</p>
<h4 id="payload-section-decrypted-data">Payload Section Decrypted data</h4>
<p>Encrypted length is the remainder of the data. Decrypted length is 16
less than the encrypted length. All block types are supported. Typical
contents include the following blocks:</p>
<p>+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&ndash;+
| Payload Block Type   | Type Number | Block Length |
+======================+=============+==============+
| DateTime             | &gt; 0         | &gt; 7          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&ndash;+
| Termination (TBD)    | &gt; 4         | &gt; 9 typ.     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&ndash;+
| Options (TBD)        | &gt; 5         | &gt; 21+        |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&ndash;+
| Message Number (TBD) | &gt; 6         | &gt; TBD        |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&ndash;+
| Next Key             | &gt; 7         | &gt; 3 or 35    |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&ndash;+
| ACK                  | &gt; 8         | &gt; 4 typ.     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&ndash;+
| ACK Request          | &gt; 9         | &gt; 3          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&ndash;+
| Garlic Clove         | &gt; 11        | &gt; varies     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&ndash;+
| Padding              | &gt; 254       | &gt; varies     |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&ndash;+</p>
<h4 id="unencrypted-data">Unencrypted data</h4>
<p>There are zero or more blocks in the encrypted frame. Each block
contains a one-byte identifier, a two-byte length, and zero or more
bytes of data.</p>
<p>For extensibility, receivers MUST ignore blocks with unknown type
nunmbers, and treat them as padding.</p>
<p>Encrypted data is 65535 bytes max, including a 16-byte authentication
header, so the max unencrypted data is 65519 bytes.</p>
<p>(Poly1305 auth tag not shown):</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ size
| data | +----+----+----+ + | | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+ size
| data | +----+----+----+ + | | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+ ~ .
. . ~</p>
<dl>
<dt>blk :: 1 byte</dt>
<dd>0 datetime 1-3 reserved 4 termination 5 options 6 previous message
number 7 next session key 8 ack 9 ack request 10 reserved 11
Garlic Clove 224-253 reserved for experimental features 254 for
padding 255 reserved for future extension</dd>
</dl>
<p>size :: 2 bytes, big endian, size of data to follow, 0 - 65516 data ::
the data</p>
<p>Maximum ChaChaPoly frame is 65535 bytes. Poly1305 tag is 16 bytes
Maximum total block size is 65519 bytes Maximum single block size is
65519 bytes Block type is 1 byte Block length is 2 bytes Maximum
single block data size is 65516 bytes.</p>
</blockquote>
<h4 id="block-ordering-rules">Block Ordering Rules</h4>
<p>In the New Session message, the DateTime block is required, and must be
the first block.</p>
<p>Other allowed blocks:</p>
<ul>
<li>Garlic Clove (type 11)</li>
<li>Options (type 5)</li>
<li>Padding (type 254)</li>
</ul>
<p>In the New Session Reply message, no blocks are required.</p>
<p>Other allowed blocks:</p>
<ul>
<li>Garlic Clove (type 11)</li>
<li>Options (type 5)</li>
<li>Padding (type 254)</li>
</ul>
<p>No other blocks are allowed. Padding, if present, must be the last
block.</p>
<p>In the Existing Session message, no blocks are required, and order is
unspecified, except for the following requirements:</p>
<p>Termination, if present, must be the last block except for Padding.
Padding, if present, must be the last block.</p>
<p>There may be multiple Garlic Clove blocks in a single frame. There may
be up to two Next Key blocks in a single frame. Multiple Padding blocks
are not allowed in a single frame. Other block types probably won't
have multiple blocks in a single frame, but it is not prohibited.</p>
<h4 id="datetime">DateTime</h4>
<p>An expiration. Assists in reply prevention. Bob must validate that the
message is recent, using this timestamp. Bob must implement a Bloom
filter or other mechanism to prevent replay attacks, if the time is
valid. Generally included in New Session messages only.</p>
<blockquote>
<p>+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+
| 0  | &gt;  |    |    | t  | ta |    |
|    |  4 |    |    | im | mp |    |
|    |    |    |    | es |    |    |
+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+</p>
<p>blk :: 0 size :: 2 bytes, big endian, value = 4 timestamp :: Unix
timestamp, unsigned seconds. Wraps around in 2106</p>
</blockquote>
<h4 id="garlic-clove">Garlic Clove</h4>
<p>A single decrypted Garlic Clove as specified in [I2NP], with
modifications to remove fields that are unused or redundant. Warning:
This format is significantly different than the one for ElGamal/AES.
Each clove is a separate payload block. Garlic Cloves may not be
fragmented across blocks or across ChaChaPoly frames.</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ |
11 | size | | +----+----+----+ + | Delivery Instructions
| ~ ~ ~ ~ | |
+----+----+----+----+----+----+----+----+
Message_ID | Expiration
+----+----+----+----+----+----+----+----+ |
I2NP Message body | +----+ + ~ ~ ~ ~ | |
+----+----+----+----+----+----+----+----+</p>
<p>size :: size of all data to follow</p>
<dl>
<dt>Delivery Instructions :: As specified in</dt>
<dd>the Garlic Clove section of [I2NP]. Length varies but is
typically 1, 33, or 37 bytes</dd>
</dl>
<p>type :: I2NP message type</p>
<p>Message_ID :: 4 byte [Integer] I2NP message ID</p>
<p>Expiration :: 4 bytes, seconds since the epoch</p>
</blockquote>
<p>[Integer]: /spec/common-structures#type-integer</p>
<p>Notes:</p>
<ul>
<li>Implementers must ensure that when reading a block, malformed or
malicious data will not cause reads to overrun into the next block.</li>
<li>The Clove Set format specified in [I2NP] is not used. Each clove
is contained in its own block.</li>
<li>The I2NP message header is 9 bytes, with an identical format to that
used in [NTCP2].</li>
<li>The Certificate, Message ID, and Expiration from the Garlic Message
definition in [I2NP] are not included.</li>
<li>The Certificate, Clove ID, and Expiration from the Garlic Clove
definition in [I2NP] are not included.</li>
</ul>
<h4 id="termination">Termination</h4>
<p>Implementation is optional. Drop the session. This must be the last
non-padding block in the frame. No more messages will be sent in this
session.</p>
<p>Not allowed in NS or NSR. Only included in Existing Session messages.</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ | 4
| size | rsn| addl data | +----+----+----+----+ + ~ .
. . ~
+----+----+----+----+----+----+----+----+</p>
<p>blk :: 4 size :: 2 bytes, big endian, value = 1 or more rsn :: reason,
1 byte: 0: normal close or unspecified 1: termination received others:
optional, impementation-specific addl data :: optional, 0 or more
bytes, for future expansion, debugging, or reason text. Format
unspecified and may vary based on reason code.</p>
</blockquote>
<h4 id="options">Options</h4>
<p>UNIMPLEMENTED, for further study. Pass updated options. Options include
various parameters for the session. See the Session Tag Length Analysis
section below for more information.</p>
<p>The options block may be variable length, as more_options may be
present.</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ | 5
| size flg STimeout |
+----+----+----+----+----+----+----+----+ |
SOTW | RITW tmaxrmax|
+----+----+----+----+----+----+----+----+ |
tdmy | rdmy | tdelay | rdelay |
+----+----+----+----+----+----+----+----+ |
more_options | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</p>
<p>blk :: 5 size :: 2 bytes, big endian, size of options to follow, 21
bytes minimum ver :: Protocol version, must be 0 flg :: 1 byte flags
bits 7-0: Unused, set to 0 for future compatibility STL :: Session tag
length (must be 8), other values unimplemented STimeout :: Session
idle timeout (seconds), big endian SOTW :: Sender Outbound Tag Window,
2 bytes big endian RITW :: Receiver Inbound Tag Window 2 bytes big
endian</p>
<dl>
<dt>tmin, tmax, rmin, rmax :: requested padding limits</dt>
<dd>tmin and rmin are for desired resistance to traffic analysis. tmax
and rmax are for bandwidth limits. tmin and tmax are the transmit
limits for the router sending this options block. rmin and rmax
are the receive limits for the router sending this options block.
Each is a 4.4 fixed-point float representing 0 to 15.9375 (or
think of it as an unsigned 8-bit integer divided by 16.0). This is
the ratio of padding to data. Examples: Value of 0x00 means no
padding Value of 0x01 means add 6 percent padding Value of 0x10
means add 100 percent padding Value of 0x80 means add 800 percent
(8x) padding Alice and Bob will negotiate the minimum and maximum
in each direction. These are guidelines, there is no enforcement.
Sender should honor receiver's maximum. Sender may or may not
honor receiver's minimum, within bandwidth constraints.</dd>
</dl>
<p>tdmy: Max dummy traffic willing to send, 2 bytes big endian, bytes/sec
average rdmy: Requested dummy traffic, 2 bytes big endian, bytes/sec
average tdelay: Max intra-message delay willing to insert, 2 bytes big
endian, msec average rdelay: Requested intra-message delay, 2 bytes
big endian, msec average</p>
<p>more_options :: Format undefined, for future use</p>
</blockquote>
<p>SOTW is the sender's recommendation to the receiver for the receiver's
inbound tag window (the maximum lookahead). RITW is the sender's
declaration of the inbound tag window (maximum lookahead) that he plans
to use. Each side then sets or adjusts the lookahead based on some
minimum or maximum or other calculation.</p>
<p>Notes:</p>
<ul>
<li>Support for non-default session tag length will hopefully never be
required.</li>
<li>The tag window is MAX_SKIP in the Signal documentation.</li>
</ul>
<p>Issues:</p>
<ul>
<li>Options negotiation is TBD.</li>
<li>Defaults TBD.</li>
<li>Padding and delay options are copied from NTCP2, but those options
have not been fully implemented or studied there.</li>
</ul>
<h4 id="message-numbers-1">Message Numbers</h4>
<p>Implementation is optional. The length (number of messages sent) in the
previous tag set (PN). Receiver may immediately delete tags higher than
PN from the previous tag set. Receiver may expire tags less than or
equal to PN from the previous tag set after a short time (e.g. 2
minutes).</p>
<blockquote>
<p>+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+
| 6  | &gt;  | e  | &gt;  |    |
|    |  s |    | PN |    |
|    | iz |    |    |    |
+&mdash;-+&mdash;-+&mdash;-+&mdash;-+&mdash;-+</p>
<p>blk :: 6 size :: 2 PN :: 2 bytes big endian. The index of the last tag
sent in the previous tag set.</p>
</blockquote>
<p>Notes:</p>
<ul>
<li>Maximum PN is 65535.</li>
<li>The definitions of PN is equal to the definition Signal, minus one.
This is similar to what Signal does, but in Signal, PN and N are in
the header. Here, they're in the encrypted message body.</li>
<li>Do not send this block in tag set 0, because there was no previous
tag set.</li>
</ul>
<h4 id="next-dh-ratchet-public-key">Next DH Ratchet Public Key</h4>
<p>The next DH ratchet key is in the payload, and it is optional. We don't
ratchet every time. (This is different than in signal, where it is in
the header, and sent every time)</p>
<p>For the first ratchet, Key ID = 0.</p>
<p>Not allowed in NS or NSR. Only included in Existing Session messages.</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ | 7
| size key ID | | +----+----+----+----+----+----+</p>
<ul>
<li>| | + + | Next DH Ratchet Public Key | + + | | +
+----+----+ | |
+----+----+----+----+----+----+</li>
</ul>
<p>blk :: 7 size :: 3 or 35 flag :: 1 byte flags bit order: 76543210 bit
0: 1 for key present, 0 for no key present bit 1: 1 for reverse key, 0
for forward key bit 2: 1 to request reverse key, 0 for no request only
set if bit 1 is 0 bits 7-2: Unused, set to 0 for future compatibility
key ID :: The key ID of this key. 2 bytes, big endian 0 - 32767 Public
Key :: The next X25519 public key, 32 bytes, little endian Only if bit
0 is 1</p>
</blockquote>
<p>Notes:</p>
<ul>
<li>Key ID is an incrementing counter for the local key used for that
tag set, starting at 0.</li>
<li>The ID must not change unless the key changes.</li>
<li>It may not be strictly necessary, but it's useful for debugging.
Signal does not use a key ID.</li>
<li>The maximum Key ID is 32767.</li>
<li>In the rare case that the tag sets in both directions are ratcheting
at the same time, a frame will contain two Next Key blocks, one for
the forward key and one for the reverse key.</li>
<li>Key and tag set ID numbers must be sequential.</li>
<li>See the DH Ratchet section above for details.</li>
</ul>
<h4 id="ack">Ack</h4>
<p>This is only sent if an ack request block was received. Multiple acks
may be present to ack multiple messages.</p>
<p>Not allowed in NS or NSR. Only included in Existing Session messages.</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ | 8
| size N | |
+----+----+----+----+----+----+----+ + | more
acks | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</p>
<p>blk :: 8 size :: 4 * number of acks to follow, minimum 1 ack for each
ack: tagsetid :: 2 bytes, big endian, from the message being acked N
:: 2 bytes, big endian, from the message being acked</p>
</blockquote>
<p>Notes:</p>
<ul>
<li>The tag set ID and N uniquely identify the message being acked.</li>
<li>In the first tag sets used for a session in each direction, the tag
set ID is 0.</li>
<li>No NextKey blocks have been sent, so there are no key IDs.</li>
<li>For all tag sets used after NextKey exchanges, The tag set number is
(1 + Alice's key ID + Bob's key ID).</li>
</ul>
<h4 id="ack-request">Ack Request</h4>
<p>Request an in-band ack. To replace the out-of-band DeliveryStatus
Message in the Garlic Clove.</p>
<p>If an explicit ack is requested, the current tagset ID and message
number (N) are returned in an ack block.</p>
<p>Not allowed in NS or NSR. Only included in Existing Session messages.</p>
<blockquote>
<p>+&mdash;-+&mdash;-+&mdash;-+&mdash;-+
| &gt;  | &gt;  | e  | f  |
|  9 |  s |    | lg |
|    | iz |    |    |
+&mdash;-+&mdash;-+&mdash;-+&mdash;-+</p>
<p>blk :: 9 size :: 1 flg :: 1 byte flags bits 7-0: Unused, set to 0 for
future compatibility</p>
</blockquote>
<h4 id="padding">Padding</h4>
<p>All padding is inside AEAD frames. TODO Padding inside AEAD should
roughly adhere to the negotiated parameters. TODO Alice sent her
requested tx/rx min/max parameters in the NS message. TODO Bob sent his
requested tx/rx min/max parameters in the NSR message. Updated options
may be sent during the data phase. See options block information above.</p>
<p>If present, this must be the last block in the frame.</p>
<blockquote>
<p>+----+----+----+----+----+----+----+----+ size
| padding | +----+----+----+ + | | ~ . . . ~ | |
+----+----+----+----+----+----+----+----+</p>
<p>blk :: 254 size :: 2 bytes, big endian, 0-65516 padding :: zeros or
random data</p>
</blockquote>
<p>Notes:</p>
<ul>
<li>All-zero padding is fine, as it will be encrypted.</li>
<li>Padding strategies TBD.</li>
<li>Padding-only frames are allowed.</li>
<li>Padding default is 0-15 bytes.</li>
<li>See options block for padding parameter negotiation</li>
<li>See options block for min/max padding parameters</li>
<li>Router response on violation of negotiated padding is
implementation-dependent.</li>
</ul>
<h4 id="other-block-types">Other block types</h4>
<p>Implementations should ignore unknown block types for forward
compatibility.</p>
<h4 id="future-work">Future work</h4>
<ul>
<li>The padding length is either to be decided on a per-message basis
and estimates of the length distribution, or random delays should be
added. These countermeasures are to be included to resist DPI, as
message sizes would otherwise reveal that I2P traffic is being
carried by the transport protocol. The exact padding scheme is an
area of future work, Appendix A provides more information on the
topic.</li>
</ul>
<h2 id="typical-usage-patterns">Typical Usage Patterns</h2>
<h3 id="http-get">HTTP GET</h3>
<p>This is the most typical use case, and most non-HTTP streaming use cases
will be identical to this use case as well. A small initial message is
sent, a reply follows, and additional messages are sent in both
directions.</p>
<p>An HTTP GET generally fits in a single I2NP message. Alice sends a small
request with a single new Session message, bundling a reply leaseset.
Alice includes immediate ratchet to new key. Includes sig to bind to
destination. No ack requested.</p>
<p>Bob ratchets immediately.</p>
<p>Alice ratchets immediately.</p>
<p>Continues on with those sessions.</p>
<blockquote>
<p>Alice Bob</p>
<p>New Session (1b) -------------------&gt; with
ephemeral key 1 with static key for binding with next key with bundled
HTTP GET with bundled LS without bundled Delivery Status Message</p>
<p>any retransmissions, same as above</p>
<p>following messages may arrive in any order:</p>
<dl>
<dt>&lt;-------------- New Session Reply (1g)</dt>
<dd>with Bob ephemeral key 1 with bundled HTTP reply part 1</dd>
<dt>&lt;-------------- New Session Reply (1g)</dt>
<dd>with Bob ephemeral key 2 with bundled HTTP reply part 2</dd>
<dt>&lt;-------------- New Session Reply (1g)</dt>
<dd>with Bob ephemeral key 3 with bundled HTTP reply part 3</dd>
</dl>
<p>After reception of any of these messages, Alice switches to use
Existing Session messages, creates a new inbound + outbound session
pair, and ratchets.</p>
<p>Existing Session -------------------&gt; with bundled
streaming ack</p>
<p>Existing Session -------------------&gt; with bundled
streaming ack</p>
<p>After reception of any of these messages, Bob switches to use Existing
Session messages.</p>
<dl>
<dt>&lt;-------------- Existing Session</dt>
<dd>with bundled HTTP reply part 4</dd>
</dl>
<p>Existing Session -------------------&gt; with bundled
streaming ack</p>
<dl>
<dt>&lt;-------------- Existing Session</dt>
<dd>with bundled HTTP reply part 5</dd>
</dl>
</blockquote>
<h3 id="http-post">HTTP POST</h3>
<p>Alice has three options:</p>
<ol>
<li>Send the first message only (window size = 1), as in HTTP GET. Not
recommended.</li>
<li>Send up to streaming window, but using same Elligator2-encoded
cleartext public key. All messages contain same next public key
(ratchet). This will be visible to OBGW/IBEP because they all start
with the same cleartext. Things proceed as in 1). Not recommended.</li>
<li>Recommended implementation. Send up to streaming window, but using a
different Elligator2-encoded cleartext public key (session) for
each. All messages contain same next public key (ratchet). This will
not be visible to OBGW/IBEP because they all start with different
cleartext. Bob must recognize that they all contain the same next
public key, and respond to all with the same ratchet. Alice uses
that next public key and continues.</li>
</ol>
<p>Option 3 message flow:</p>
<blockquote>
<p>Alice Bob</p>
<p>New Session (1b) -------------------&gt; with
ephemeral key 1 with static key for binding with bundled HTTP POST
part 1 with bundled LS without bundled Delivery Status Message</p>
<p>New Session (1b) -------------------&gt; with
ephemeral key 2 with static key for binding with bundled HTTP POST
part 2 with bundled LS without bundled Delivery Status Message</p>
<p>New Session (1b) -------------------&gt; with
ephemeral key 3 with static key for binding with bundled HTTP POST
part 3 with bundled LS without bundled Delivery Status Message</p>
<p>following messages can arrive in any order:</p>
<dl>
<dt>&lt;-------------- New Session Reply (1g)</dt>
<dd>with Bob ephemeral key 1 with bundled streaming ack</dd>
<dt>&lt;-------------- New Session Reply (1g)</dt>
<dd>with Bob ephemeral key 2 with bundled streaming ack</dd>
</dl>
<p>After reception of any of these messages, Alice switches to use
Existing Session messages, creates a new inbound + outbound session
pair, and ratchets.</p>
<p>following messages can arrive in any order:</p>
<p>Existing Session -------------------&gt; with bundled
HTTP POST part 4</p>
<p>Existing Session -------------------&gt; with next key
with bundled HTTP POST part 5</p>
<p>After reception of any of these messages, Bob switches to use Existing
Session messages.</p>
<dl>
<dt>&lt;-------------- Existing Session</dt>
<dd>with bundled streaming ack</dd>
</dl>
<p>After reception of any of this message, Alice switches to use Existing
Session messages, and Alice ratchets.</p>
<p>Existing Session -------------------&gt; with next key
with bundled HTTP POST part 4</p>
<p>after reception of this message, Bob ratchets</p>
<p>Existing Session -------------------&gt; with next key
with bundled HTTP POST part 5</p>
<dl>
<dt>&lt;-------------- Existing Session</dt>
<dd>with bundled streaming ack</dd>
</dl>
</blockquote>
<h3 id="repliable-datagram">Repliable Datagram</h3>
<p>A single message, with a single reply expected. Additional messages or
replies may be sent.</p>
<p>Similar to HTTP GET, but with smaller options for session tag window
size and lifetime. Maybe don't request a ratchet.</p>
<blockquote>
<p>Alice Bob</p>
<p>New Session (1b) -------------------&gt; with static
key for binding with next key with bundled repliable datagram with
bundled LS without bundled Delivery Status Message</p>
<dl>
<dt>&lt;-------------- New Session Reply (1g)</dt>
<dd>with Bob ephemeral key with bundled reply part 1</dd>
<dt>&lt;-------------- New Session Reply (1g)</dt>
<dd>with Bob ephemeral key with bundled reply part 2</dd>
</dl>
<p>After reception of either message, Alice switches to use Existing
Session messages, and ratchets.</p>
<p>If the Existing Session message arrives first, Alice ratchets on the
existing inbound and outbound sessions.</p>
<p>When the New Session Reply arrives, Alice sets the existing inbound
session to expire, creates a new inbound and outbound session, and
sends Existing Session messages on the new outbound session.</p>
<p>Alice keeps the expiring inbound session around for a while to process
the Existing Session message sent to Alice. If all expected original
Existing Session message replies have been processed, Alice can expire
the original inbound session immediately.</p>
<p>if there are any other messages:</p>
<p>Existing Session -------------------&gt; with bundled
message</p>
<p>Existing Session -------------------&gt; with bundled
streaming ack</p>
<dl>
<dt>&lt;-------------- Existing Session</dt>
<dd>with bundled message</dd>
</dl>
</blockquote>
<h3 id="multiple-raw-datagrams">Multiple Raw Datagrams</h3>
<p>Multiple anonymous messages, with no replies expected.</p>
<p>In this scenario, Alice requests a session, but without binding. New
session message is sent. No reply LS is bundled. A reply DSM is bundled
(this is the only use case that requires bundled DSMs). No next key is
included. No reply or ratchet is requested. No ratchet is sent. Options
set session tags window to zero.</p>
<blockquote>
<p>Alice Bob</p>
<p>New Session (1c) -------------------&gt; with bundled
message without bundled LS with bundled Delivery Status Message 1</p>
<p>New Session (1c) -------------------&gt; with bundled
message without bundled LS with bundled Delivery Status Message 2</p>
<p>New Session (1c) -------------------&gt; with bundled
message without bundled LS with bundled Delivery Status Message 3</p>
<p>following messages can arrive in any order:</p>
<p>&lt;-------------- Delivery Status Message 1</p>
<p>&lt;-------------- Delivery Status Message 2</p>
<p>&lt;-------------- Delivery Status Message 3</p>
<p>After reception of any of these messages, Alice switches to use
Existing Session messages.</p>
<p>Existing Session -------------------&gt;</p>
<p>Existing Session -------------------&gt;</p>
<p>Existing Session -------------------&gt;</p>
</blockquote>
<h3 id="single-raw-datagram">Single Raw Datagram</h3>
<p>A single anonymous messages, with no reply expected.</p>
<p>One-time message is sent. No reply LS or DSM are bundled. No next key is
included. No reply or ratchet is requested. No ratchet is sent. Options
set session tags window to zero.</p>
<blockquote>
<p>Alice Bob</p>
<p>One-Time Message (1d) -------------------&gt; with
bundled message without bundled LS without bundled Delivery Status
Message</p>
</blockquote>
<h3 id="long-lived-sessions">Long-Lived Sessions</h3>
<p>Long-lived sessions may ratchet, or request a ratchet, at any time, to
maintain forward secrecy from that point in time. Sessions must ratchet
as they approach the limit of sent messages per-session (65535).</p>
<h2 id="implementation-considerations">Implementation Considerations</h2>
<h3 id="defense">Defense</h3>
<p>As with the existing ElGamal/AES+SessionTag protocol, implementations
must limit session tag storage and protect against memory exhaustion
attacks.</p>
<p>Some recommended strategies include:</p>
<ul>
<li>Hard limit on number of session tags stored</li>
<li>Aggressive expiration of idle inbound sessions when under memory
pressure</li>
<li>Limit on number of inbound sessions bound to a single far-end
destination</li>
<li>Adaptive reduction of session tag window and deletion of old unused
tags when under memory pressure</li>
<li>Refusal to ratchet when requested, if under memory pressure</li>
</ul>
<h3 id="parameters">Parameters</h3>
<p>Recommended parameters and timeouts:</p>
<ul>
<li>NSR tagset size: 12 tsmin and tsmax</li>
<li>ES tagset 0 size: tsmin 24, tsmax 160</li>
<li>ES tagset (1+) size: 160 tsmin and tsmax</li>
<li>NSR tagset timeout: 3 minutes for receiver</li>
<li>ES tagset timeout: 8 minutes for sender, 10 minutes for receiver</li>
<li>Remove previous ES tagset after: 3 minutes</li>
<li>Tagset look ahead of tag N: min(tsmax, tsmin + N/4)</li>
<li>Tagset trim behind tag N: min(tsmax, tsmin + N/4) / 2</li>
<li>Send next key at tag: 4096</li>
<li>Send next key after tagset lifetime: TBD</li>
<li>Replace session if NS received after: 3 minutes</li>
<li>Max clock skew: -5 minutes to +2 minutes</li>
<li>NS replay filter duration: 5 minutes</li>
<li>Padding size: 0-15 bytes (other strategies TBD)</li>
</ul>
<h3 id="classification">Classification</h3>
<p>Following are recommendations for classifying incoming messages.</p>
<h4 id="x25519-only">X25519 Only</h4>
<p>On a tunnel that is solely used with this protocol, do identification as
is done currently with ElGamal/AES+SessionTags:</p>
<p>First, treat the initial data as a session tag, and look up the session
tag. If found, decrypt using the stored data associated with that
session tag.</p>
<p>If not found, treat the initial data as a DH public key and nonce.
Perform a DH operation and the specified KDF, and attempt to decrypt the
remaining data.</p>
<h4 id="x25519-shared-with-elgamalaessessiontags">X25519 Shared with ElGamal/AES+SessionTags</h4>
<p>On a tunnel that supports both this protocol and
ElGamal/AES+SessionTags, classify incoming messages as follows:</p>
<p>Due to a flaw in the ElGamal/AES+SessionTags specification, the AES
block is not padded to a random non-mod-16 length. Therefore, the length
of Existing Session messages mod 16 is always 0, and the length of New
Session messages mod 16 is always 2 (since the ElGamal block is 514
bytes long).</p>
<p>If the length mod 16 is not 0 or 2, treat the initial data as a session
tag, and look up the session tag. If found, decrypt using the stored
data associated with that session tag.</p>
<p>If not found, and the length mod 16 is not 0 or 2, treat the initial
data as a DH public key and nonce. Perform a DH operation and the
specified KDF, and attempt to decrypt the remaining data. (based on the
relative traffic mix, and the relative costs of X25519 and ElGamal DH
operations, ths step may be done last instead)</p>
<p>Otherwise, if the length mod 16 is 0, treat the initial data as a
ElGamal/AES session tag, and look up the session tag. If found, decrypt
using the stored data associated with that session tag.</p>
<p>If not found, and the data is at least 642 (514 + 128) bytes long, and
the length mod 16 is 2, treat the initial data as a ElGamal block.
Attempt to decrypt the remaining data.</p>
<p>Note that if the ElGamal/AES+SessionTag spec is updated to allow
non-mod-16 padding, things will need to be done differently.</p>
<h3 id="protocol-layer-responses">Protocol-layer Responses</h3>
<p>Initial implementations rely on bidirectional traffic at the higher
layers. That is, the implementations assume that traffic in the opposite
direction will soon be transmitted, which will force any required
response at the ECIES layer.</p>
<p>However, certain traffic may be unidirectional or very low bandwidth,
such that there is no higher-layer traffic to generate a timely
response.</p>
<p>Receipt of NS and NSR messages require a response; receipt of ACK
Request and Next Key blocks also require a response.</p>
<p>A sophisticated implementation may start a timer when one of these
messages is received which requires a response, and generate an
&quot;empty&quot; (no Garlic Clove block) response at the ECIES layer if no
reverse traffic is sent in a short period of time (e.g. 1 second).</p>
<p>It may also be appropriate for an even shorter timeout for responses to
NS and NSR messages, to shift the traffic to the efficient ES messages
as soon as possible.</p>
<h2 id="related-changes">Related Changes</h2>
<p>Database Lookups from ECIES Destinations: See [Prop154], now
incorporated in [I2NP] for release 0.9.46.</p>
<p>This specification requires LS2 support to publish the X25519 public key
with the leaseset. No changes are required to the LS2 specifications in
[I2NP]. All support was designed, specified, and implemented in
[Prop123] implemented in 0.9.38.</p>
<p>This specification requires a property to be set in the I2CP options to
be enabled. All support was designed, specified, and implemented in
[Prop123] implemented in 0.9.38.</p>
<p>The option required to enable ECIES is a single I2CP property for I2CP,
BOB, SAM, or i2ptunnel.</p>
<p>Typical values are i2cp.leaseSetEncType=4 for ECIES only, or
i2cp.leaseSetEncType=4,0 for ECIES and ElGamal dual keys.</p>
<h2 id="compatibility">Compatibility</h2>
<p>Any router supporting LS2 with dual keys (0.9.38 or higher) should
support connection to destinations with dual keys.</p>
<p>ECIES-only destinations require a majority of the floodfills to be
updated to 0.9.46 to get encrypted lookup replies. See [Prop154].</p>
<p>ECIES-only destinations can only connect with other destinations that
are either ECIES-only, or dual-key.</p>
<h2 id="references">References</h2>
<dl>
<dt>[Common]</dt>
<dd>
<p><a href="https://geti2p.net/spec/common-structures">https://geti2p.net/spec/common-structures</a></p>
</dd>
<dt>[CRYPTO-ELG]</dt>
<dd>
<p><a href="https://geti2p.net/en/docs/how/cryptography#elgamal">https://geti2p.net/en/docs/how/cryptography#elgamal</a></p>
</dd>
<dt>[Elligator2]</dt>
<dd>
<p><a href="https://elligator.cr.yp.to/elligator-20130828.pdf">https://elligator.cr.yp.to/elligator-20130828.pdf</a>
<a href="https://www.imperialviolet.org/2013/12/25/elligator.html">https://www.imperialviolet.org/2013/12/25/elligator.html</a> See also
OBFS4 code</p>
</dd>
<dt>[ElG-AES]</dt>
<dd>
<p><a href="https://geti2p.net/en/docs/how/elgamal-aes">https://geti2p.net/en/docs/how/elgamal-aes</a></p>
</dd>
<dt>[GARLICSPEC]</dt>
<dd>
<p><a href="https://geti2p.net/en/docs/how/garlic-routing">https://geti2p.net/en/docs/how/garlic-routing</a></p>
</dd>
<dt>[I2CP]</dt>
<dd>
<p><a href="https://geti2p.net/spec/i2cp">https://geti2p.net/spec/i2cp</a></p>
</dd>
<dt>[I2NP]</dt>
<dd>
<p><a href="https://geti2p.net/spec/i2np">https://geti2p.net/spec/i2np</a></p>
</dd>
<dt>[NTCP2]</dt>
<dd>
<p><a href="https://geti2p.net/spec/ntcp2">https://geti2p.net/spec/ntcp2</a></p>
</dd>
<dt>[NOISE]</dt>
<dd>
<p><a href="https://noiseprotocol.org/noise.html">https://noiseprotocol.org/noise.html</a></p>
</dd>
<dt>[Prop111]</dt>
<dd>
<p><a href="https://geti2p.net/spec/proposals/111-ntcp-2">https://geti2p.net/spec/proposals/111-ntcp-2</a></p>
</dd>
<dt>[Prop123]</dt>
<dd>
<p><a href="https://geti2p.net/spec/proposals/123-new-netdb-entries">https://geti2p.net/spec/proposals/123-new-netdb-entries</a></p>
</dd>
<dt>[Prop142]</dt>
<dd>
<p><a href="https://geti2p.net/spec/proposals/142-new-crypto-template">https://geti2p.net/spec/proposals/142-new-crypto-template</a></p>
</dd>
<dt>[Prop144]</dt>
<dd>
<p><a href="https://geti2p.net/spec/proposals/144-ecies-x25519-aead-ratchet">https://geti2p.net/spec/proposals/144-ecies-x25519-aead-ratchet</a></p>
</dd>
<dt>[Prop145]</dt>
<dd>
<p><a href="https://geti2p.net/spec/proposals/145-ecies">https://geti2p.net/spec/proposals/145-ecies</a></p>
</dd>
<dt>[Prop152]</dt>
<dd>
<p><a href="https://geti2p.net/spec/proposals/152-ecies-tunnels">https://geti2p.net/spec/proposals/152-ecies-tunnels</a></p>
</dd>
<dt>[Prop153]</dt>
<dd>
<p><a href="https://geti2p.net/spec/proposals/153-chacha20-layer-encryption">https://geti2p.net/spec/proposals/153-chacha20-layer-encryption</a></p>
</dd>
<dt>[Prop154]</dt>
<dd>
<p><a href="https://geti2p.net/spec/proposals/154-ecies-lookups">https://geti2p.net/spec/proposals/154-ecies-lookups</a></p>
</dd>
<dt>[RFC-2104]</dt>
<dd>
<p><a href="https://tools.ietf.org/html/rfc2104">https://tools.ietf.org/html/rfc2104</a></p>
</dd>
<dt>[RFC-5869]</dt>
<dd>
<p><a href="https://tools.ietf.org/html/rfc5869">https://tools.ietf.org/html/rfc5869</a></p>
</dd>
<dt>[RFC-7539]</dt>
<dd>
<p><a href="https://tools.ietf.org/html/rfc7539">https://tools.ietf.org/html/rfc7539</a></p>
</dd>
<dt>[RFC-7748]</dt>
<dd>
<p><a href="https://tools.ietf.org/html/rfc7748">https://tools.ietf.org/html/rfc7748</a></p>
</dd>
<dt>[RFC-7905]</dt>
<dd>
<p><a href="https://tools.ietf.org/html/rfc7905">https://tools.ietf.org/html/rfc7905</a></p>
</dd>
<dt>[RFC-4880-S5.1]</dt>
<dd>
<p><a href="https://tools.ietf.org/html/rfc4880#section-5.1">https://tools.ietf.org/html/rfc4880#section-5.1</a></p>
</dd>
<dt>[Signal]</dt>
<dd>
<p><a href="https://signal.org/docs/specifications/doubleratchet/">https://signal.org/docs/specifications/doubleratchet/</a></p>
</dd>
<dt>[SSU]</dt>
<dd>
<p><a href="https://geti2p.net/en/docs/transport/ssu">https://geti2p.net/en/docs/transport/ssu</a></p>
</dd>
<dt>[STS]</dt>
<dd>
<p>Diffie, W.; van Oorschot P. C.; Wiener M. J., Authentication and
Authenticated Key Exchanges</p>
</dd>
</dl>

  </div>
</section>



    

    
    <div id="backtotop"><a href="#"></a></div>

    

    

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
<script src="https://unpkg.com/feather-icons"></script>
<script src="/i2p.spec/js/fresh.js"></script>
<script src="/i2p.spec/js/jquery.panelslider.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script>
  </body>
</html>
